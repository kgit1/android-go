Reverse a String 
Reverse the provided string.
You may need to turn the string into an array before you can reverse it.

Your result must be a string.
function reverseString(str) {
  var arr = str.split("");
  console.log("arr:" + arr);
  var revarr=arr.reverse();
  
  console.log("revarr: " + revarr);
  str=revarr.join("");
  console.log("string: " + str);
  return str;
}

reverseString("hello");

reverseString("hello") should return a string.
reverseString("hello") should become "olleh".
reverseString("Howdy") should become "ydwoH".
reverseString("Greetings from Earth") should return "htraE morf sgniteerG".

##############################################################################################################

Factorialize a Number 
Return the factorial of the provided integer.

If the integer is represented with the letter n, a factorial is the product of all positive integers less than or equal to n.

Factorials are often represented with the shorthand notation n!

For example: 5! = 1 * 2 * 3 * 4 * 5 = 120

  result=1;
  for(var i=1;i<=num;i++){
    result*=i;
    console.log("i:"+i+" result:"+result);
  }
  num=result;
  console.log(num);
  return num;
}

factorialize(5);

factorialize(5) should return a number.
factorialize(5) should return 120.
factorialize(10) should return 3628800.
factorialize(20) should return 2432902008176640000.
factorialize(0) should return 1.
##############################################################################################################

Check for Palindromes 
Return true if the given string is a palindrome. Otherwise, return false.

A palindrome is a word or sentence that's spelled the same way both forward and backward, ignoring punctuation, case, and spacing.
Note
You'll need to remove all non-alphanumeric characters (punctuation, spaces and symbols) and turn everything lower case in order to check for palindromes.
We'll pass strings with varying formats, such as "racecar", "RaceCar", and "race CAR" among others.
We'll also pass strings with special symbols, such as "2A3*3a2", "2A3 3a2", and "2_A3*3#A2".

function palindrome(str) {
  // Good luck!
  console.log("str " + str);
  var tempStr=str.toLowerCase();
  console.log("temp " +tempStr);
//   tempStr=tempStr.replace(/ /gi,"");
  tempStr=tempStr.replace(/[() .,_-]/g,"");

  
  console.log("temp " +tempStr);
  var arr=tempStr.split("");
  var reverse=arr.reverse();
  console.log("reverse:"+reverse.join(""));
  if(tempStr==reverse.join("")){
    return true;
  }
  return false;
}
palindrome("eye");


palindrome("eye") should return a boolean.
palindrome("eye") should return true.
palindrome("_eye") should return true.
palindrome("race car") should return true.
palindrome("not a palindrome") should return false.
palindrome("A man, a plan, a canal. Panama") should return true.
palindrome("never odd or even") should return true.
palindrome("nope") should return false.
palindrome("almostomla") should return false.
palindrome("My age is 0, 0 si ega ym.") should return true.
palindrome("1 eye for of 1 eye.") should return false.
palindrome("0_0 (: /-\ :) 0-0") should return true.
palindrome("five|\_/|four") should return false.
##############################################################################################################

Find the Longest Word in a String 
Return the length of the longest word in the provided sentence.
Your response should be a number.

  result=0;
  var arr=str.split(" ");
  for(var i=0;i<arr.length;i++){
    if(arr[i].length>result){
      result=arr[i].length;
    }
  }
  return result;
}

findLongestWord("The quick brown fox jumped over the lazy dog");

findLongestWord("The quick brown fox jumped over the lazy dog") should return a number.
findLongestWord("The quick brown fox jumped over the lazy dog") should return 6.
findLongestWord("May the force be with you") should return 5.
findLongestWord("Google do a barrel roll") should return 6.
findLongestWord("What is the average airspeed velocity of an unladen swallow") should return 8.
findLongestWord("What if we try a super-long word such as otorhinolaryngology") should return 19.
##############################################################################################################

Title Case a Sentence 
Return the provided string with the first letter of each word capitalized. Make sure the rest of the word is in lower case.

For the purpose of this exercise, you should also capitalize connecting words like "the" and "of".

  var arr =str.split(" ");
  console.log(arr);
  for(var i =0;i<arr.length;i++){
    var temp = arr[i].split("");
    
    temp[0]=temp[0].toUpperCase();
    if(temp.length>1){
      for(var j=1;j<temp.length;j++){
        temp[j]=temp[j].toLowerCase();
      }
    }
    
    
    
    console.log(temp[0]);
    arr[i]=temp.join("");
  }
  console.log("result:"+arr);
  str=arr.join(" ");
  console.log("str:"+str);
  return arr.join(" ");
}

titleCase("I'm a little tea pot");

titleCase("I'm a little tea pot") should return a string.
titleCase("I'm a little tea pot") should return "I'm A Little Tea Pot".
titleCase("sHoRt AnD sToUt") should return "Short And Stout".
titleCase("HERE IS MY HANDLE HERE IS MY SPOUT") should return "Here Is My Handle Here Is My Spout".
##############################################################################################################

Return Largest Numbers in Arrays 
Return an array consisting of the largest number from each provided sub-array. For simplicity, the provided array will contain exactly 4 sub-arrays.

Remember, you can iterate through an array with a simple for loop, and access each member with array syntax arr[i].

function largestOfFour(arr) {
  // You can do this!
  var result=[];
  for(var i=0;i<arr.length;i++){
    var max=arr[i][0];
    for(var j=1;j<arr[i].length;j++){
      if(arr[i][j]>max){
        max=arr[i][j];
      }
    }
    result.push(max);
  }
  console.log(result);
  return result;
}

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);

largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]) should return an array.
largestOfFour([[13, 27, 18, 26], [4, 5, 1, 3], [32, 35, 37, 39], [1000, 1001, 857, 1]]) should return [27,5,39,1001].
largestOfFour([[4, 9, 1, 3], [13, 35, 18, 26], [32, 35, 97, 39], [1000000, 1001, 857, 1]]) should return [9, 35, 97, 1000000].
##############################################################################################################

Confirm the Ending 
Check if a string (first argument, str) ends with the given target string (second argument, target).

This challenge can be solved with the .endsWith() method, which was introduced in ES2015. But for the purpose of this challenge, we would like you to use one of the JavaScript substring methods instead.

function confirmEnding(str, target) {
  // "Never give up and good luck will find you."
  // -- Falcor
  var temp=str.split("");
  var testStr=[];
  if(target.length<=str.length){
    for(var i=str.length-target.length;i<str.length;i++){
      testStr.push(temp[i]);
    }
  }
  console.log("str:"+str+" test:"+testStr.join("")+" target:"+target);
  
  return target==testStr.join("");
}

confirmEnding("Bastian", "n");

confirmEnding("Bastian", "n") should return true.
confirmEnding("Connor", "n") should return false.
confirmEnding("Walking on water and developing software from a specification are easy if both are frozen", "specification") should return false.
confirmEnding("He has to give me a new name", "name") should return true.
confirmEnding("Open sesame", "same") should return true.
confirmEnding("Open sesame", "pen") should return false.
confirmEnding("If you want to save our world, you must hurry. We dont know how much longer we can withstand the nothing", "mountain") should return false.
Do not use the built-in method .endsWith() to solve the challenge.
##############################################################################################################

Repeat a string repeat a string 
Repeat a given string (first argument) num times (second argument). Return an empty string if num is not a positive number.

function repeatStringNumTimes(str, num) {
  // repeat after me
  if(num<1){
    return "";
  }
  if(num>1){
    var temp="";
    for(var i=0;i<num;i++){
      temp+=str;
    }
    str=temp;
  }
  console.log(num+" "+str);
  return str;
}

repeatStringNumTimes("abc", 3);

repeatStringNumTimes("*", 3) should return "***".
repeatStringNumTimes("abc", 3) should return "abcabcabc".
repeatStringNumTimes("abc", 4) should return "abcabcabcabc".
repeatStringNumTimes("abc", 1) should return "abc".
repeatStringNumTimes("*", 8) should return "********".
repeatStringNumTimes("abc", -2) should return "".
##############################################################################################################

Truncate a string 
Truncate a string (first argument) if it is longer than the given maximum string length (second argument). Return the truncated string with a ... ending.

Note that inserting the three dots to the end will add to the string length.

However, if the given maximum string length num is less than or equal to 3, then the addition of the three dots does not add to the string length in determining the truncated string.

function truncateString(str, num) {
  // Clear out that junk in your trunk
  
  if(str.length>num){
  var tempArr=str.split("");
  var finalLength=num;
    if(num>3){
    finalLength-=3;
    }
    for(var i=0;i<(str.length-finalLength);i++){
    tempArr.pop();
    }
    str=tempArr.join("")+"...";
  console.log(str);
  }
  return str;
}

truncateString("A-tisket a-tasket A green and yellow basket", 11);

truncateString("A-tisket a-tasket A green and yellow basket", 11) should return "A-tisket...".
truncateString("Peter Piper picked a peck of pickled peppers", 14) should return "Peter Piper...".
truncateString("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length) should return "A-tisket a-tasket A green and yellow basket".
truncateString("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length + 2) should return "A-tisket a-tasket A green and yellow basket".
truncateString("A-", 1) should return "A...".
truncateString("Absolutely Longer", 2) should return "Ab...".
##############################################################################################################

Chunky Monkey 
Write a function that splits an array (first argument) into groups the length of size (second argument) and returns them as a two-dimensional array.

  // Break it up.
  console.log("start:"+arr);
  var result=[];
  var tempArr=[];
  var counter=0;
  var chunks=Math.floor(arr.length/size);
//   var chunk=Math.floor(arr.length/size);
//   console.log(chunk);
  if(arr.length%size>0){
    counter=chunks+1;
  }else{
    counter=arr.length/size;
  }
  console.log("counter:"+counter);
  for(var i=0;i<chunks;i++){
//     console.log("slice:"+arr.slice(1,3));
    console.log("size*i:"+size*i);
    tempArr=arr.slice(0+size*i,size*i+size);
    console.log("tempArr:"+tempArr);
    result.push(tempArr);
    console.log("result:"+result);
    console.log("--------------------");
    counter--;
    console.log("counter:"+counter);
  }
  if(counter>0){
    tempArr=arr.slice(size*chunks,arr.length);
    console.log("tempArr!:"+tempArr);
    result.push(tempArr);
  }
  console.log("result!:"+result);
  console.log("======================");
  
//   for(var i=0;i<arr.length;i++){    
//     tempArr.push(arr[i]);
//     counter++;
// //     console.log(counter);
//     if(counter%size==0||i==arr.length-1){
//       console.log("temp:"+tempArr);
//       result.push(tempArr);
//       counter=0;
//       tempArr=[];
//     }
//   }
//   console.log("arr:"+arr);
//   console.log("result:"+result);
//   console.log("================");  
  return result;
}

chunkArrayInGroups(["a", "b", "c", "d"], 2);

chunkArrayInGroups(["a", "b", "c", "d"], 2) should return [["a", "b"], ["c", "d"]].
chunkArrayInGroups([0, 1, 2, 3, 4, 5], 3) should return [[0, 1, 2], [3, 4, 5]].
chunkArrayInGroups([0, 1, 2, 3, 4, 5], 2) should return [[0, 1], [2, 3], [4, 5]].
chunkArrayInGroups([0, 1, 2, 3, 4, 5], 4) should return [[0, 1, 2, 3], [4, 5]].
chunkArrayInGroups([0, 1, 2, 3, 4, 5, 6], 3) should return [[0, 1, 2], [3, 4, 5], [6]].
chunkArrayInGroups([0, 1, 2, 3, 4, 5, 6, 7, 8], 4) should return [[0, 1, 2, 3], [4, 5, 6, 7], [8]].
chunkArrayInGroups([0, 1, 2, 3, 4, 5, 6, 7, 8], 2) should return [[0, 1], [2, 3], [4, 5], [6, 7], [8]].
##############################################################################################################

Slasher Flick 
Return the remaining elements of an array after chopping off n elements from the head.

The head means the beginning of the array, or the zeroth index.

function slasher(arr, howMany) {
  // it doesn't always pay to be first
  console.log(arr.splice(0,howMany));
  return arr;
}

slasher([1, 2, 3], 2);

slasher([1, 2, 3], 2) should return [3].
slasher([1, 2, 3], 0) should return [1, 2, 3].
slasher([1, 2, 3], 9) should return [].
slasher([1, 2, 3], 4) should return [].
slasher(["burgers", "fries", "shake"], 1) should return ["fries", "shake"].
slasher([1, 2, "chicken", 3, "potatoes", "cheese", 4], 5) should return ["cheese", 4].
##############################################################################################################

Mutations 
Return true if the string in the first element of the array contains all of the letters of the string in the second element of the array.

For example, ["hello", "Hello"], should return true because all of the letters in the second string are present in the first, ignoring case.

The arguments ["hello", "hey"] should return false because the string "hello" does not contain a "y".

Lastly, ["Alien", "line"], should return true because all of the letters in "line" are present in "Alien".

function mutation(arr) {
  
  var first=arr[0].toLowerCase().split("");
  var second =arr[1].toLowerCase().split("");
  
  console.log(first);
  for(var i =0;i<second.length;i++){
    if(first.indexOf(second[i])<0){
      console.log(first.indexOf(second[i]));
      return false;
    }
  }
  
console.log("++++++++++++++++++++++");
  
  return true;
}

mutation(["hello", "hey"]);

mutation(["hello", "hey"]) should return false.
mutation(["hello", "Hello"]) should return true.
mutation(["zyxwvutsrqponmlkjihgfedcba", "qrstu"]) should return true.
mutation(["Mary", "Army"]) should return true.
mutation(["Mary", "Aarmy"]) should return true.
mutation(["Alien", "line"]) should return true.
mutation(["floor", "for"]) should return true.
mutation(["hello", "neo"]) should return false.
mutation(["voodoo", "no"]) should return false.
##############################################################################################################

Falsy Bouncer 
Remove all falsy values from an array.

Falsy values in JavaScript are false, null, 0, "", undefined, and NaN.

function bouncer(arr) {
  // Don't show a false ID to this bouncer.
  var result=arr.filter(function(val){
    console.log("val:"+ val );
    console.log(val!=0&&!isNaN(val));
    return val;});
      //!isNaN(val)&&val!==0&&val!==false&&val!==""&&val!==null
// We can check null by ===
//if ( value === null ){}
//Just by using if
//if( value ) {}
//will evaluate to true if value is not:
//null
//undefined
//NaN
//empty string ("")
//false
//0
  console.log("result:"+result+"\n===========");
  return result;
}

bouncer([7, "ate", "", false, 9]);

bouncer([7, "ate", "", false, 9]) should return [7, "ate", 9].
bouncer(["a", "b", "c"]) should return ["a", "b", "c"].
bouncer([false, null, 0, NaN, undefined, ""]) should return [].
bouncer([1, null, NaN, 2, undefined]) should return [1, 2].
##############################################################################################################

Seek and Destroy 
You will be provided with an initial array (the first argument in the destroyer function), followed by one or more arguments. Remove all elements from the initial array that are of the same value as these arguments.

function destroyer(arr,first,second) {
  // Remove all the values
  var arrTemp=arguments[0];
  var args=[];
  for(var i=1;i<arguments.length;i++){
    args.push(arguments[i]);
  }
  
  for(var j=0;j<args.length;j++){
   arrTemp=arrTemp.filter(function(val){
      console.log("val:"+val);
      console.log("arg:"+args[j]);
      return val!=args[j];});
    console.log("!result:"+arrTemp);
  }
  console.log("arr:"+arguments[0]);
 
  console.log("result:"+arrTemp);
  console.log("++++++++++++++++++++++++");
  
  return arrTemp;
}

destroyer([1, 2, 3, 1, 2, 3], 2, 3);

destroyer([1, 2, 3, 1, 2, 3], 2, 3) should return [1, 1].
destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3) should return [1, 5, 1].
destroyer([3, 5, 1, 2, 2], 2, 3, 5) should return [1].
destroyer([2, 3, 2, 3], 2, 3) should return [].
destroyer(["tree", "hamburger", 53], "tree", 53) should return ["hamburger"].
##############################################################################################################

Where do I belong 
Return the lowest index at which a value (second argument) should be inserted into an array (first argument) once it has been sorted. The returned value should be a number.

For example, getIndexToIns([1,2,3,4], 1.5) should return 1 because it is greater than 1 (index 0), but less than 2 (index 1).

Likewise, getIndexToIns([20,3,5], 19) should return 2 because once the array has been sorted it will look like [3,5,20] and 19 is less than 20 (index 2) and greater than 5 (index 1).

  // Find my place in this sorted array.
  var tempArr=arr.sort(function(a,b){return a>b;});
  var place=0;
  for(var i=0;i<tempArr.length;i++){
    if(num>tempArr[i]){
      place++;
    }
  }
  console.log("arr2:"+tempArr);
  console.log("arr1:"+arr);
  console.log("place:"+place+" num:"+num);
  console.log("==============");
  return place;
}

getIndexToIns([40, 60], 50);

getIndexToIns([10, 20, 30, 40, 50], 35) should return 3.
getIndexToIns([10, 20, 30, 40, 50], 30) should return 2.
getIndexToIns([40, 60], 50) should return 1.
getIndexToIns([3, 10, 5], 3) should return 0.
getIndexToIns([5, 3, 20, 3], 5) should return 2.
getIndexToIns([2, 20, 10], 19) should return 2.
getIndexToIns([2, 5, 10], 15) should return 3.
##############################################################################################################

Caesars Cipher 
One of the simplest and most widely known ciphers is a Caesar cipher, also known as a shift cipher. In a shift cipher the meanings of the letters are shifted by some set amount.

A common modern use is the ROT13 cipher, where the values of the letters are shifted by 13 places. Thus 'A' - 'N', 'B' - 'O' and so on.

Write a function which takes a ROT13 encoded string as input and returns a decoded string.

All letters will be uppercase. Do not transform any non-alphabetic character (i.e. spaces, punctuation), but do pass them on.

function rot13(str) { // LBH QVQ VG!
//   str="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  console.log("str:"+str);
  var tempStr="";
  var tempCarCode=0;
  for(var i=0;i<str.length;i++){
   tempCharCode=str.charCodeAt(i); console.log(tempCharCode+":"+String.fromCharCode(tempCharCode));
    
    if(tempCharCode>64 &&tempCharCode<92){
    if(tempCharCode>77){
      tempCharCode-=13;
    }else{
      tempCharCode+=13;
    }}
    tempStr+=String.fromCharCode(tempCharCode);
  }
//   console.log()
  console.log("result: "+tempStr);
  console.log("============");
  return tempStr;
}

// Change the inputs below to test
rot13("SERR PBQR PNZC");

rot13("SERR PBQR PNZC") should decode to "FREE CODE CAMP"
rot13("SERR CVMMN!") should decode to "FREE PIZZA!"
rot13("SERR YBIR?") should decode to "FREE LOVE?"
rot13("GUR DHVPX OEBJA QBT WHZCRQ BIRE GUR YNML SBK.") should decode to "THE QUICK BROWN DOG JUMPED OVER THE LAZY FOX."
##############################################################################################################

Sum All Numbers in a Range 
We'll pass you an array of two numbers. Return the sum of those two numbers and all numbers between them.

The lowest number will not always come first.

function sumAll(arr) {
  //can give error on big arrays
  console.log("min: "+Math.min.apply(null,arr));
  var min=Math.min.apply(null,arr);
  var max=Math.max.apply(null,arr);
  var result=0;
  //for big arrays
//   console.log("min: "+arr.reduce(function(a,b){return Math.min(a,b);}));
//  function arrayMax(array) {
//   return array.reduce(function(a, b) {
//     return Math.max(a, b);
//   });
// }  
  //in ES6
//   function arrayMax(array) {
//   return array.reduce((a, b) => Math.max(a, b));
// }
  //or even just
  //Math.max(...arr);  
  
    for(var i=min;i<=max;i++){
      result+=i;
    }
  return result;
}

sumAll([1, 4,5,6,7,8,9]);


//SOLUTION
Intermediate Code Solution:
// function sumAll(arr) {
//   // Buckle up everything to one!

//   // Using ES6 arrow function (one-liner)
//   var sortedArr = arr.sort((a,b) => a-b);
//   var firstNum = arr[0];
//   var lastNum = arr[1];
//   // Using Arithmetic Progression summing formula

//   var sum = (lastNum - firstNum + 1) * (firstNum + lastNum) / 2;
//   return sum;
// }
// :rocket: Run Code35

// Code Explanation:
// Firstly, we create a variable called sortedArr which sorts it from the lowest to the highest value.
// firstNum is equal to the first number and lastNum is equal to the second number.
// Next, using the Arithmetic Progression summing formula we let sum equal (lastNum - firstNum + 1) * (firstNum + lastNum) / 2.
// Finally, we return sum.
// The line var sortedArr = arr.sort((a,b) => a-b); is probably what will have you more confused. This would be the same as creating a function that returns a-b for the sort() which is the standard way to sort numbers from smallest to largest. Instead using arrow or fat arrow function, we are able to do all that in one single line thus allowing us to write less.

// Relevant Links
// Array.sort()12
// Arithmetic Progression summing formula123
// ES6 arrow function66
// :rotating_light: Advanced Code Solution:
// function sumAll(arr) {
//     var sum = 0;
//     for (var i = Math.min(...arr); i <= Math.max(...arr); i++){
//         sum += i;
//     }
//   return sum;
// }

// sumAll([1, 4]);
// :rocket: Run Code61

// Code Explanation:
// Creating a variable sum to store the sum of the elements.
// Starting iteration of the loop from min element of given array and stopping when it reaches the max element.
// Using a spread operator (…arr) allows passing the actual array to the function instead of one-by-one elements.

sumAll([1, 4]) should return a number.
sumAll([1, 4]) should return 10.
sumAll([4, 1]) should return 10.
sumAll([5, 10]) should return 45.
sumAll([10, 5]) should return 45.
##############################################################################################################

Diff Two Arrays 
Compare two arrays and return a new array with any items only found in one of the two given arrays, but not both. In other words, return the symmetric difference of the two arrays.

function diffArray(arr1, arr2) {
  console.log("==================");
  var newArr = arr1.concat(arr2);
    newArr=newArr.filter(function(val){
    var index=newArr.indexOf(val);
    return newArr.indexOf(val,index+1)==-1;
  });
  console.log(newArr);
  
  return newArr;
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);

//SOLUTION
Intermediate Code Solution (Declarative Solution):
function diffArray(arr1, arr2) {
  return arr1
    .concat(arr2)
    .filter(
        item => !arr1.includes(item) || !arr2.includes(item)
    )
}

Advanced Code Solution (Declarative Solution):
function diffArray(arr1, arr2) {
    return arr1
      .filter(el => !arr2.includes(el))
      .concat(
        arr2.filter(el => !arr1.includes(el))
      )
}

diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]) should return an array.
["diorite", "andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"] should return ["pink wool"].
["andesite", "grass", "dirt", "pink wool", "dead shrub"], ["diorite", "andesite", "grass", "dirt", "dead shrub"] should return ["diorite", "pink wool"].
["andesite", "grass", "dirt", "dead shrub"], ["andesite", "grass", "dirt", "dead shrub"] should return [].
[1, 2, 3, 5], [1, 2, 3, 4, 5] should return [4].
[1, "calf", 3, "piglet"], [1, "calf", 3, 4] should return ["piglet", 4].
[], ["snuffleupagus", "cookie monster", "elmo"] should return ["snuffleupagus", "cookie monster", "elmo"].
[1, "calf", 3, "piglet"], [7, "filly"] should return [1, "calf", 3, "piglet", 7, "filly"].
##############################################################################################################

Roman Numeral Converter 
Convert the given number into a roman numeral.

All roman numerals answers should be provided in upper-case.

var str="";
var result=[];
var nu=0;
convertToRoman(36);

function convertToRoman(num) {
  str=""; 
  result=[];
 nu=num;
  
  if(nu>=1000){
    if(nu==1000){
      console.log("MILLLLLLLLLLLLLLLLL");
      result.push("M");
    }
    else if(nu>1000&& nu<=4000){
      numberMil(nu);
    }    
    result.push(str);
  }  
  console.log("number: "+nu);
  if(nu>=100 && nu<1000){
    if(nu>=900){
      nu%=100;
      result.push("CM");
    }
    else if(nu>500&& nu<900){      
      centuries(nu-500);
      result.push("D"+str);
    }else if(nu==500){
      result.push("D");
    }
    else if(nu>=400 && nu<500){
      nu%=100;
      result.push("CD");
    }else if(nu>100 && nu<400){
      str="";
      for(var i=0;i<Math.floor(nu/100);i++){
        str+="C";
      }
      nu%=100;
      result.push(str);
    }else if(nu==100){
      result.push("C");
    }
  }
  if(nu>10 && nu<100){
    if(nu>=90){
      nu%=10;
      result.push("XC");
    }else if(nu>50&&nu<90){
      nu-=50;
      tenth(nu);
      result.push("L"+str);
    }else if(nu==50){
      result.push("L");
    }else if(nu>=40&&nu<50){
      nu%=10;
      result.push("XL");
    }else if(nu<40){
      tenth(nu);
      console.log("NU<40");
      result.push(str);
    }
  }
 
   if(nu==10){
    result.push("X");
  }
  if(nu<10){
  if(nu==9){
    result.push("IX");
  }
  else if(nu>=5 &&nu<=8){
    nu-=5;
    ones(nu);
    result.push("V"+str);
  }
  else if(nu==4){
    result.push("IV");
  }else 
    if(nu<4){
      ones(nu);
      result.push(str);
    }
  }
  
   result=result.filter(function(val){
    return val;
  });
  console.log("result: "+result);
 
 return result.join("");
}


function numberMil(num){
  str="";  
  console.log("MATH: "+Math.floor(num/1000));
    for(var i=0;i<Math.floor(num/1000);i++){
      str+="M";
    }    
    console.log("nu: "+nu +" mils: "+str);
    nu%=1000;
    console.log("MILSnu: "+nu);
}

function ones(num){ 
   str="";
   for(var i=0;i<num;i++){
     str+="I";
   }
 }

function centuries(num){
  str="";
  for(var i=0;i<Math.floor(num/100);i++){
    str+="C";
  }
  nu%=100;
  console.log("CENTnu: "+nu);
}
function tenth(num){
  str="";
  for(var i=0;i<Math.floor(num/10);i++){
    str+="X";
  }
  nu%=10;
  console.log("TENTnu: "+nu+" str - "+str);
}

//SOLUTION
Basic Code Solution:
var convertToRoman = function(num) {

  var decimalValue = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];
  var romanNumeral = [ 'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I' ];

  var romanized = '';

  for (var index = 0; index < decimalValue.length; index++) {
    while (decimalValue[index] <= num) {
      romanized += romanNumeral[index];
      num -= decimalValue[index];
    }
  }

  return romanized;
}

// test here
convertToRoman(36);
:rocket: Run Code455

Code Explanation:
We start off by creating two arrays with default conversion with matching indices. These are called decimalValue and romanNumeral. We also create an empty string variable, romanized, which will house the final roman number.
Using a for loop, we loop through the indicies of the decimalValue array. We continue to loop until while the value at the current index will fit into num.
Next, we add the roman numeral and decrease num by the decimal equivalent.
Finally, we return the value of romanized.
Relevant Links
For Loops13
While Loops
:sunflower: Intermediate Code Solution:
function convertToRoman(num) {
 var romans = ["I", "V", "X", "L", "C", "D", "M"],
     ints = [],
     romanNumber = [],
     numeral = "";
  while (num) {
    ints.push(num % 10);
    num = Math.floor(num/10);
  }
  for (i=0; i<ints.length; i++){
      units(ints[i]);
  }
  function units(){
    numeral = romans[i*2];
    switch(ints[i]) {
      case 1:
        romanNumber.push(numeral);
        break;
      case 2:
        romanNumber.push(numeral.concat(numeral));
        break;
      case 3:
        romanNumber.push(numeral.concat(numeral).concat(numeral));
        break;
      case 4:
        romanNumber.push(numeral.concat(romans[(i*2)+1]));
        break;
      case 5:
        romanNumber.push(romans[(i*2)+1]);
        break;
      case 6:
        romanNumber.push(romans[(i*2)+1].concat(numeral));
        break;
      case 7:
        romanNumber.push(romans[(i*2)+1].concat(numeral).concat(numeral));
        break;
      case 8:
        romanNumber.push(romans[(i*2)+1].concat(numeral).concat(numeral).concat(numeral));
        break;
      case 9:
        romanNumber.push(romans[i*2].concat(romans[(i*2)+2]));
      }
    }
  return romanNumber.reverse().join("").toString();
}

// test here
convertToRoman(97);
:rocket: Run Code103

Code Explanation:
Create an array of Roman Numerals (romans).
Use a for loop to create an array of the digits (ints) in the number.
Loop through the array of digits (base 10) and as you do, increment the Roman Numeral (base 5) index by 2 (numeral = romans[i*2]).
Within the loop, use Switch Case to push the proper Roman Numerals (backwards) onto that array.
Reverse the Roman Numerals array and turn it into a string.
Relevant Links
For Loops13
While Loops
Math12
:sunflower: Intermediate Code Solution:
function convertToRoman(num) {
  var romans = [
  // 10^i 10^i*5
    ["I", "V"], // 10^0
    ["X", "L"], // 10^1
    ["C", "D"], // 10^2
    ["M"]       // 10^3
  ],
      digits = num.toString()
        .split('')
        .reverse()
        .map(function(item, index) {
          return parseInt(item);
        }),
      numeral = "";
  
  // Loop through each digit, starting with the ones place
  for (var i=0; i<digits.length; i++) {
    // Make a Roman numeral that ignores 5-multiples and shortening rules
    numeral = romans[i][0].repeat(digits[i]) + numeral;
    // Check for a Roman numeral 5-multiple version
    if (romans[i][1]) {
      numeral = numeral
        // Change occurrences of 5 * 10^i to the corresponding 5-multiple Roman numeral
        .replace(romans[i][0].repeat(5), romans[i][1])
        // Shorten occurrences of 9 * 10^i
        .replace(romans[i][1] + romans[i][0].repeat(4), romans[i][0] + romans[i+1][0])
        // Shorten occurrences of 4 * 10^i
        .replace(romans[i][0].repeat(4), romans[i][0] + romans[i][1]);
    }
  }
  
  return numeral;
}

// test here
convertToRoman(36);

:rocket: Run Code103

Code Explanation:
Use an array (romans) to create a matrix containing the Roman numeral for a given power of 10 and, if available, the Roman numeral for that power of 10 times 5.
Convert the input number (num) to a reversed array of digits (digits) so that we can loop through those digits starting with the ones position and going up.
Loop through each digit, starting with the ones place, and create a Roman numeral string by adding each higher-power Roman numeral to the start of the numeral string a number of times equal to digit. This initial string ignores the Roman numerals that are a power of 10 times 5 and also ignores shortening rules.
If the relevant power of 10 has a 5-multiple Roman numeral, in numeral, replace 5-in-a-row occurrences with the relevant 5-multiple Roman numeral (i.e., V, L, or D) and shorten occurrences of 9 * 10^i (e.g., VIIII to VIX) and 4 * 10^i (e.g., XXXX to XL). Order is important here!
Finally, return numeral.


convertToRoman(2) should return "II".
convertToRoman(3) should return "III".
convertToRoman(4) should return "IV".
convertToRoman(5) should return "V".
convertToRoman(9) should return "IX".
convertToRoman(12) should return "XII".
convertToRoman(16) should return "XVI".
convertToRoman(29) should return "XXIX".
convertToRoman(44) should return "XLIV".
convertToRoman(45) should return "XLV"
convertToRoman(68) should return "LXVIII"
convertToRoman(83) should return "LXXXIII"
convertToRoman(97) should return "XCVII"
convertToRoman(99) should return "XCIX"
convertToRoman(500) should return "D"
convertToRoman(501) should return "DI"
convertToRoman(649) should return "DCXLIX"
convertToRoman(798) should return "DCCXCVIII"
convertToRoman(891) should return "DCCCXCI"
convertToRoman(1000) should return "M"
convertToRoman(1004) should return "MIV"
convertToRoman(1006) should return "MVI"
convertToRoman(1023) should return "MXXIII"
convertToRoman(2014) should return "MMXIV"
convertToRoman(3999) should return "MMMCMXCIX"
##############################################################################################################

Search and Replace 
Perform a search and replace on the sentence using the arguments provided and return the new sentence.

First argument is the sentence to perform the search and replace on.

Second argument is the word that you will be replacing (before).

Third argument is what you will be replacing the second argument with (after).

NOTE: Preserve the case of the original word when you are replacing it. For example if you mean to replace the word "Book" with the word "dog", it should be replaced as "Dog"

function myReplace(str, before, after) {
  console.log("=====================");
  var temp=before.split("");
  if(temp[0]==temp[0].toUpperCase()){
    temp=after.split("");
    temp[0]=temp[0].toUpperCase();
    after=temp.join("");
  }
  console.log(temp);
  console.log(before+" "+after);
  str=str.replace(before,after);
  
  console.log(str);
  return str;
}

myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");

//SOLUTION
Basic Code Solution:
function myReplace(str, before, after) {
  // Find index where before is on string
  var index = str.indexOf(before);
  // Check to see if the first letter is uppercase or not
  if (str[index] === str[index].toUpperCase()) {
    // Change the after word to be capitalized before we use it.
    after = after.charAt(0).toUpperCase() + after.slice(1);
  }
  // Now replace the original str with the edited one.
  str = str.replace(before, after);

  return str;
}

// test here
myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");
:rocket: Run Code62

Code Explanation:
Use indexOf() to find location of before in string.
If first letter of before is capitalized, change first letter of after to uppercase.
Replace before in the string with after.
Return the new string.
Relevant Links
JS String Prototype IndexOf9
JS String Prototype ToUpperCase2
JS String Prototype CharAt7
JS String Prototype Slice13
:sunflower: Intermediate Code Solution:
function myReplace(str, before, after) {
//Create a regular expression object
  var re = new RegExp(before,"gi");
//Check whether the first letter is uppercase or not
  if(/[A-Z]/.test(before[0])){
  //Change the word to be capitalized
    after = after.charAt(0).toUpperCase()+after.slice(1);
     }
     //Replace the original word with new one
  var  newStr =  str.replace(re,after);

 return newStr;
}

// test here
myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");
:rocket: Run Code18

Code Explanation:
In this solution, regular expression [A-Z] is used to check if character is uppercase.
Create a new regular expression object, re.
If first letter of before is capitalized, change the first letter of after to uppercase.
Replace before with after in the string.
Return the new string.
Relevant Links
JS Regex Resources
:rotating_light: Advanced Code Solution:
function myReplace(str, before, after) {

    // create a function that will change the casing of any number of letter in parameter "target"
    // matching parameter "source"
    function applyCasing(source, target) {
        // split the source and target strings to array of letters
        var targetArr = target.split("");
        var sourceArr = source.split("");
        // iterate through all the items of sourceArr and targetArr arrays till loop hits the end of shortest array
        for (var i = 0; i < Math.min(targetArr.length, sourceArr.length); i++){
            // find out the casing of every letter from sourceArr using regular expression
            // if sourceArr[i] is upper case then convert targetArr[i] to upper case
            if (/[A-Z]/.test(sourceArr[i])) {
                targetArr[i] = targetArr[i].toUpperCase();
            }
            // if sourceArr[i] is not upper case then convert targetArr[i] to lower case
            else targetArr[i] = targetArr[i].toLowerCase();
        }
        // join modified targetArr to string and return
        return (targetArr.join(""));
    }


    // replace "before" with "after" with "before"-casing
    return str.replace(before, applyCasing(before, after));
}

// test here
myReplace("A quick brown fox jumped over the lazy dog", "jumped", "leaped");
:rocket: Run Code12

Code Explanation:
Both the before and after are passed as arguments to applyCasing().
The function applyCasing() is used to change the case of respective characters in targetArr i.e., after in accordance with that of characters in sourceArr i.e., before.
replace() is used to replace before with after, whose casing is same as before.

myReplace("Let us go to the store", "store", "mall") should return "Let us go to the mall".
myReplace("He is Sleeping on the couch", "Sleeping", "sitting") should return "He is Sitting on the couch".
myReplace("This has a spellngi error", "spellngi", "spelling") should return "This has a spelling error".
myReplace("His name is Tom", "Tom", "john") should return "His name is John".
myReplace("Let us get back to more Coding", "Coding", "algorithms") should return "Let us get back to more Algorithms".
##############################################################################################################

Pig Latin 
Translate the provided string to pig latin.

Pig Latin takes the first consonant (or consonant cluster) of an English word, moves it to the end of the word and suffixes an "ay".

If a word begins with a vowel you just add "way" to the end.

Input strings are guaranteed to be English words in all lowercase.

function translatePigLatin(str) {
  console.log("############################");
  var vowelIndex=-1;
  for(var i=0;vowelIndex==-1&&i<str.length;i++){
    var char=str.charAt(i);
    if(char==="a"||char==="e"||char==="i"||char==="o"||char==="u"){
      vowelIndex=i;
    }
  }
  if(vowelIndex===0){
    str+="way";
  }else{
    str+=str.substring(0,vowelIndex);
    str=str.substring(vowelIndex);
    str+="ay";
    console.log("preprefin: "+str);
  }
  return str; 
  
 //WORKING through ARRAYS 
//   var temp=str.split("");
//   var vowelIndex=-1;
//   for(var i=0;vowelIndex==-1&&i<temp.length;i++){
//     switch(temp[i]){
//         //A, E, I, O, and U
//       case "a":
//         vowelIndex=i;
//         break;
//          case "e":
//         vowelIndex=i;
//         break;
//          case "i":
//         vowelIndex=i;
//         break;
//          case "o":
//         vowelIndex=i;
//         break;
//          case "u":
//         vowelIndex=i;
//         break;
//     }
//   }
//   console.log("vowelIndex:"+vowelIndex);
//   if(vowelIndex===0){
//     temp.push("way");
//   }else{
//     temp.push(temp.slice(0,vowelIndex).join(""));
//     temp=temp.slice(vowelIndex,temp.length);
//     temp.push("ay");
//   }
//   var fin=temp.join('');
//   console.log("fin:"+fin);
//   return temp.join("");
}

translatePigLatin("consonant");

translatePigLatin("california") should return "aliforniacay".
translatePigLatin("paragraphs") should return "aragraphspay".
translatePigLatin("glove") should return "oveglay".
translatePigLatin("algorithm") should return "algorithmway".
translatePigLatin("eight") should return "eightway".
##############################################################################################################

DNA Pairing 
The DNA strand is missing the pairing element. Take each character, get its pair, and return the results as a 2d array.

Base pairs are a pair of AT and CG. Match the missing element to the provided character.

Return the provided character as the first element in each array.

For example, for the input GCG, return [["G", "C"], ["C","G"],["G", "C"]]

The character and its pair are paired up in an array, and all the arrays are grouped into one encapsulating array.

function pairElement(str) {
  console.log("######################");
  var arr=str.slice("");
  var result=[];
  console.log(str);
  for(var i=0;i<arr.length;i++){
    var temp=[];
    temp.push(arr[i]);
    if(arr[i]==="A"){      
      temp.push("T");
    }else if(arr[i]==="T"){
      temp.push("A");
    }
    else if(arr[i]==="G"){
      temp.push("C");
    }
    else if(arr[i]==="C"){
      temp.push("G");
    }
    result.push(temp);
    console.log(result);
  }
  return result;
}

pairElement("GCG");

pairElement("ATCGA") should return [["A","T"],["T","A"],["C","G"],["G","C"],["A","T"]].
pairElement("TTGAG") should return [["T","A"],["T","A"],["G","C"],["A","T"],["G","C"]].
pairElement("CTCTA") should return [["C","G"],["T","A"],["C","G"],["T","A"],["A","T"]].
##############################################################################################################

Missing letters 
Find the missing letter in the passed letter range and return it.

If all letters are present in the range, return undefined.

function fearNotLetter(str) {
  var arr=str.slice("");
  var answer;
  for(var i=0;i<str.length;i++){
    if(str.charCodeAt(i)-str.charCodeAt(i+1)<-1){
      answer=String.fromCharCode(str.charCodeAt(i)+1);
    }
  }
  return answer;
}

fearNotLetter("abce");

fearNotLetter("abce") should return "d".
fearNotLetter("abcdefghjklmno") should return "i".
fearNotLetter("bcd") should return undefined.
fearNotLetter("yz") should return undefined.
##############################################################################################################

Boo who 
Check if a value is classified as a boolean primitive. Return true or false.

Boolean primitives are true and false.

function booWho(bool) {
  // What is the new fad diet for ghost developers? The Boolean.
  var answer=(typeof(bool)==typeof(true));
  return answer;
}

booWho(null);

booWho(true) should return true.
booWho(false) should return true.
booWho([1, 2, 3]) should return false.
booWho([].slice) should return false.
booWho({ "a": 1 }) should return false.
booWho(1) should return false.
booWho(NaN) should return false.
booWho("a") should return false.
booWho("true") should return false.
booWho("false") should return false.
##############################################################################################################

Sorted Union 
Write a function that takes two or more arrays and returns a new array of unique values in the order of the original provided arrays.

In other words, all values present from all arrays should be included in their original order, but with no duplicates in the final array.

The unique numbers should be sorted by their original order, but the final array should not be sorted in numerical order.

Check the assertion tests for examples.

function uniteUnique(arr) {
  console.log("#############################");
  var tempArr=arguments[0];
 for(var i=1;i<arguments.length;i++){
    tempArr=tempArr.concat(arguments[i]);
  }
  console.log("tempArr:"+tempArr);
 //filter duplicates
  tempArr=tempArr.reduce(function(acc,val){
    console.log("val: "+val);
    if(typeof(acc)!="object"){
      acc=[acc];
    }
    if(acc.indexOf(val)===-1){
    acc.push(val);
    }
    console.log("acc: "+acc);
    return acc;
  });
  
//filter uniques
//   tempArr=tempArr.filter(function(val){
   
//     return tempArr.indexOf(val,tempArr.indexOf(val)+1)==-1;
//   });
  console.log("tempArr:"+tempArr);
  return tempArr;
}

uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]);

uniteUnique([1, 3, 2], [5, 2, 1, 4], [2, 1]) should return [1, 3, 2, 5, 4].
uniteUnique([1, 3, 2], [1, [5]], [2, [4]]) should return [1, 3, 2, [5], [4]].
uniteUnique([1, 2, 3], [5, 2, 1]) should return [1, 2, 3, 5].
uniteUnique([1, 2, 3], [5, 2, 1, 4], [2, 1], [6, 7, 8]) should return [1, 2, 3, 5, 4, 6, 7, 8].
##############################################################################################################

Convert HTML Entities 
Convert the characters &, <, >, " (double quote), and ' (apostrophe), in a string to their corresponding HTML entities.

function convertHTML(str) {
  // &colon;&rpar;
  console.log("#############################");
  str=str.replace(/&|<|>|\"|\'/g,function(match){
//     console.log("val: ");
    console.log("val: "+match);
    if(match==="&"){
    return "&amp;";}
    if(match==="<"){
    return "&lt;";}
    if(match===">"){
    return "&gt;";}
    if(match==='\"'){
    return "&quot;";}
    if(match==="\'"){
    return "&apos;";}
  });
 
  console.log(str);
  return str;
}

convertHTML("Dolce & Gabbana");

convertHTML("Dolce & Gabbana") should return Dolce &?amp; Gabbana.
convertHTML("Hamburgers < Pizza < Tacos") should return Hamburgers &?lt; Pizza &?lt; Tacos.
convertHTML("Sixty > twelve") should return Sixty &?gt; twelve.
convertHTML('Stuff in "quotation marks"') should return Stuff in &?quot;quotation marks&?quot;.
convertHTML("Shindler's List") should return Shindler&?apos;s List.
convertHTML("<>") should return &?lt;&?gt;.
convertHTML("abc") should return abc.
##############################################################################################################

Spinal Tap Case 
Convert a string to spinal case. Spinal case is all-lowercase-words-joined-by-dashes.

function spinalCase(str) {
  // "It's such a fine line between stupid, and clever."
  // --David St. Hubbins
  console.log("################");
  str=str.replace(/[A-Z]|_|\s(?=[a-z])/g,function(match,offset){
    console.log("match: "+match);
    console.log("offset: "+offset);
    if(match==="_"){
       return "";       
    }else if(match===" "){
      return "-";
    }
    else{
      return ((offset>0)?"-"+match.toLowerCase():match.toLowerCase());
         }
  });
  console.log("str: "+str);
//   str=str.replace(/\s/,function(match){
//     return "-";
//   });
  console.log("fin: "+str.replace(/\s/,""));
  return str.replace(/\s/g,"");
}

spinalCase('This Is Spinal Tap');

spinalCase("This Is Spinal Tap") should return "this-is-spinal-tap".
spinalCase("thisIsSpinalTap") should return "this-is-spinal-tap".
spinalCase("The_Andy_Griffith_Show") should return "the-andy-griffith-show".
spinalCase("Teletubbies say Eh-oh") should return "teletubbies-say-eh-oh".
spinalCase("AllThe-small Things") should return "all-the-small-things".
##############################################################################################################

Sum All Odd Fibonacci Numbers 
Given a positive integer num, return the sum of all odd Fibonacci numbers that are less than or equal to num.

The first two numbers in the Fibonacci sequence are 1 and 1. Every additional number in the sequence is the sum of the two previous numbers. The first six numbers of the Fibonacci sequence are 1, 1, 2, 3, 5 and 8.

For example, sumFibs(10) should return 10 because all odd Fibonacci numbers less than 10 are 1, 1, 3, and 5.

function sumFibs(num) {
  if(num==1){
      return 1;
    }else{
  var fibs=[1,1];
  var currentFib=0;
  var result=2;
  for(var i=2;(fibs[i-1]+fibs[i-2])<=num;i++){
    currentFib=fibs[i-1]+fibs[i-2];
    fibs.push(currentFib);
    if(currentFib%2!=0){    
      result+=currentFib;
    }    
  }
  return result;
  }
}

sumFibs(4);
sumFibs(6);

sumFibs(1) should return a number.
sumFibs(1000) should return 1785.
sumFibs(4000000) should return 4613732.
sumFibs(4) should return 5.
sumFibs(75024) should return 60696.
sumFibs(75025) should return 135721.
##############################################################################################################

Sum All Primes 
Sum all the prime numbers up to and including the provided number.

A prime number is defined as a number greater than one and having only two divisors, one and itself. For example, 2 is a prime number because it's only divisible by one and two.

The provided number may not be a prime.

function sumPrimes(num) {
  var number=1;
  var sumOfPrimes=0;
  var prime=true;
  
  for(var i=2;i<=num;i++){
    prime=true;
    
    for(var j=2;j<i&&prime;j++){
      
      if(i%j==0){
        prime=false;
      } 
      
    } 
    
    if(prime===true){      
      sumOfPrimes+=i;
    }  
    
  }
  return sumOfPrimes;
}

sumPrimes(10);

sumPrimes(10) should return a number.
sumPrimes(10) should return 17.
sumPrimes(977) should return 73156.
##############################################################################################################

Smallest Common Multiple 
Find the smallest common multiple of the provided parameters that can be evenly divided by both, as well as by all sequential numbers in the range between these parameters.

The range will be an array of two numbers that will not necessarily be in numerical order.

e.g. for 1 and 3 - find the smallest common multiple of both 1 and 3 that is evenly divisible by all numbers between 1 and 3.

function smallestCommons(arr) {
//   console.log(arr+" ######################");
  arr=arr.sort(function(a,b){return a>b;});
//   console.log(arr);
  var counter=1;
  var result=arr[0];
  var check;
  var fin=false;
  // 
  for(var i=arr[0];!fin;i++){
      
//noprotect
    check=true;
    result=i;
    for(var j=arr[0];j<=arr[1]&&check;j++){
//       console.log("arr[0]: "+arr[0]);
      if(result%j!=0){
//         console.log("switch, result: "+result+" j: "+j+" result%j: "+result%j);
        check=false;
        j=arr[0];
      }else{
//         console.log("******result: "+result+" j: "+j+" result%j: "+result%j);
      }
      if(j==arr[1]){
        fin =true;
      }
    }
//     console.log("counter: "+counter);
//     counter++;
//     console.log("result: "+result);
  }
  console.log("##########################result: "+result);
  return result;
}


smallestCommons([18,23]);

smallestCommons([1, 5]) should return a number.
smallestCommons([1, 5]) should return 60.
smallestCommons([5, 1]) should return 60.
smallestCommons([1, 13]) should return 360360.
smallestCommons([23, 18]) should return 6056820.
##############################################################################################################

Finders Keepers 
Create a function that looks through an array (first argument) and returns the first element in the array that passes a truth test (second argument).

function findElement(arr, func) {
  arr=arr.filter(func);
  var num = arr[0];
  return num;
}

findElement([1, 2, 3, 4], function(num){ return num % 2 === 0; });

findElement([1, 3, 5, 8, 9, 10], function(num) { return num % 2 === 0; }) should return 8.
findElement([1, 3, 5, 9], function(num) { return num % 2 === 0; }) should return undefined.
##############################################################################################################

Drop it 
Drop the elements of an array (first argument), starting from the front, until the predicate (second argument) returns true.

The second argument, func, is a function you'll use to test the first elements of the array to decide if you should drop it or not.

Return the rest of the array, otherwise return an empty array.

function dropElements(arr, func) {
  // Drop them elements.
  for(var i=0;i<arr.length;i++){
    if(!func(arr[i])){
      console.log("val: "+arr[i]+" func: "+func(arr[i]));
      arr.shift();
      i--;
    }else{
      return arr;
      
    }
  }
  return arr;
}

dropElements([1, 2, 3], function(n) {return n < 3; });
dropElements([1, 2, 3, 4], function(n) {return n >= 3;}) should return [3, 4].
dropElements([0, 1, 0, 1], function(n) {return n === 1;}) should return [1, 0, 1].
dropElements([1, 2, 3], function(n) {return n > 0;}) should return [1, 2, 3].
dropElements([1, 2, 3, 4], function(n) {return n > 5;}) should return [].
dropElements([1, 2, 3, 7, 4], function(n) {return n > 3;}) should return [7, 4].
dropElements([1, 2, 3, 9, 2], function(n) {return n > 2;}) should return [3, 9, 2].

##############################################################################################################

Steamroller 
Flatten a nested array. You must account for varying levels of nesting.

function steamrollArray(arr) {
  // I'm a steamroller, baby
  console.log("===============");
  var temp=[];
  arr.forEach(function(val){
    recursive(val);  
  });
  
  function recursive(val){
    if(Array.isArray(val)){
      console.log("array: "+val);
      val.forEach(function(val){
    recursive(val);  
  });
//       recursive(val);
    }else{
      temp.push(val);
    }
  }
  console.log("result: "+temp);
  return temp;
}

steamrollArray([1, [2], [3, [[4]]]]);

steamrollArray([[["a"]], [["b"]]]) should return ["a", "b"].
steamrollArray([1, [2], [3, [[4]]]]) should return [1, 2, 3, 4].
steamrollArray([1, [], [3, [[4]]]]) should return [1, 3, 4].
steamrollArray([1, {}, [3, [[4]]]]) should return [1, {}, 3, 4].
##############################################################################################################

Binary Agents
Return an English translated sentence of the passed binary string.

The binary string will be space separated.

function binaryAgent(str) {
  var temp=str.split(" ");
  str="";
  console.log(temp);
  temp.forEach(function(val){
    str+=String.fromCharCode(parseInt(val,2));
  });
  console.log(temp);
  return str;
}

binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111");

binaryAgent("01000001 01110010 01100101 01101110 00100111 01110100 00100000 01100010 01101111 01101110 01100110 01101001 01110010 01100101 01110011 00100000 01100110 01110101 01101110 00100001 00111111") should return "Aren't bonfires fun!?"
binaryAgent("01001001 00100000 01101100 01101111 01110110 01100101 00100000 01000110 01110010 01100101 01100101 01000011 01101111 01100100 01100101 01000011 01100001 01101101 01110000 00100001") should return "I love FreeCodeCamp!"


///overkill////////////////////////////////////////////
https://ourcodeworld.com/articles/read/380/how-to-convert-a-binary-string-into-a-readable-string-and-vice-versa-with-javascript


Readable string to binary
To convert a human readable string to its binary value, use the following function:

/**
 * Function that converts a string into its binary representation
 * 
 * @see https://gist.github.com/eyecatchup/6742657
 * @author https://github.com/eyecatchup
 */
function stringToBinary(str, spaceSeparatedOctets) {
    function zeroPad(num) {
        return "00000000".slice(String(num).length) + num;
    }

    return str.replace(/[\s\S]/g, function(str) {
        str = zeroPad(str.charCodeAt().toString(2));
        return !1 == spaceSeparatedOctets ? str : str + " "
    });
};
And you can use it easily:

// "01001000 01100101 01101100 01101100 01101111 00100000 01000010 01101001 01101110 01100001 01110010 01111001 00100000 01010111 01101111 01110010 01101100 01100100"
stringToBinary("Hello Binary World");
But how does this code works ? The providen string The charCodeAt method returns the Unicode of the first character in a string. The toString() method parses its first argument, and attempts to return a string representation in the specified radix (base). For radixes above 10, the letters of the alphabet indicate numerals greater than 9. For example, for hexadecimal numbers (base 16), a through f are used.

If you provide the second parameters (spaceSeparatedOctets) to 0, then the string won't be "pretty printed" (the octets won't be separated). The test for the stringToBinary method is the following (note that the stringToBinary method adds an empty character at the end of the returned string therefore is recommendable to use the trim method to remove it):

var testsSuccesfullyExecuted = 0;
var testErrors = [];

TestBlock.forEach(function(item , index){
    var processedBinaryString = item.binary;
    // Removes the spaces from the binary string
    processedBinaryString = processedBinaryString.replace(/\s+/g, '');
     // Pretty (correct) print binary (add a space every 8 characters)
    processedBinaryString = processedBinaryString.match(/.{1,8}/g).join(" ");

    // Remove spaces at the end of the stringToBinary generated string
    if(stringToBinary(item.text).trim() == processedBinaryString){
        console.log("Test ${"+ index +"} passes");
        testsSuccesfullyExecuted++;
    }else{
        testErrors.push(index);
    }
});

if(testsSuccesfullyExecuted == TestBlock.length){
    console.log("Test suite succesfully executed with no errors");
}else{
    console.error("Test failed with : " + JSON.stringify(testErrors));
}
Providing the following output in the console:

Test ${0} passes
Test ${1} passes
Test ${2} passes
Test ${3} passes
Test ${4} passes
Test suite succesfully executed with no errors
With a standard benchmark executed in a personal computer with the following specifications:

Windows 10 Pro 64-bit (10.0, Build 14393) - Chrome Version 56.0.2924.87 (64-bit)
Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz (8 CPUs), ~3.6GHz
8192MB RAM
The function stringToBinary needed 1322.53 milliseconds to execute the test 10K times with and average execution per task of 0.13194000000025843 milliseconds.

Binary to readable string
To convert a binary string into a readable string, you can use any of the 2 following methods binaryToString or binaryAgent:

Option 1
This function removes all the empty spaces of the string and will split it into blocks of 8 characters that will be joined into a single string. Then the String.fromCharCode will do the trick for you:

function binaryToString(str) {
    // Removes the spaces from the binary string
    str = str.replace(/\s+/g, '');
    // Pretty (correct) print binary (add a space every 8 characters)
    str = str.match(/.{1,8}/g).join(" ");

    var newBinary = str.split(" ");
    var binaryCode = [];

    for (i = 0; i < newBinary.length; i++) {
        binaryCode.push(String.fromCharCode(parseInt(newBinary[i], 2)));
    }
    
    return binaryCode.join("");
}
And the usage:

// Both of them return: "Hello Binary World"
binaryToString("0100100001100101011011000110110001101111001000000100001001101001011011100110000101110010011110010010000001010111011011110111001001101100011001000010000000100001");
binaryToString("01001000 01100101 01101100 01101100 01101111 00100000 01000010 01101001 01101110 01100001 01110010 01111001 00100000 01010111 01101111 01110010 01101100 01100100 00100000 00100001");
The test code for binaryToString is the following:

var testsSuccesfullyExecuted = 0;
var testErrors = [];

TestBlock.forEach(function(item , index){
    if(binaryToString(item.binary) == item.text){
        console.log("Test ${"+ index +"} passes");
        testsSuccesfullyExecuted++;
    }else{
        testErrors.push(index);
    }
});

if(testsSuccesfullyExecuted == TestBlock.length){
    console.log("Test suite succesfully executed with no errors");
}else{
    console.error("Test failed with : " + JSON.stringify(testErrors));
}
The following test will output the following content in the console:

Test ${0} passes
Test ${1} passes
Test ${2} passes
Test ${3} passes
Test ${4} passes
Test suite succesfully executed with no errors
Option 2
In the same way the first function does, all the empty spaces will be removed and the string will be divided into blocks of 8 characters to be finally joined.

function binaryAgent(str) {
     // Removes the spaces from the binary string
     str = str.replace(/\s+/g, '');
     // Pretty (correct) print binary (add a space every 8 characters)
     str = str.match(/.{1,8}/g).join(" ");

     return str.split(" ").map(function (elem) {
         return String.fromCharCode(parseInt(elem, 2));
     }).join("");
}
And the usage:

// Both of them return: "Hello Binary World"
binaryAgent("0100100001100101011011000110110001101111001000000100001001101001011011100110000101110010011110010010000001010111011011110111001001101100011001000010000000100001");
binaryAgent("01001000 01100101 01101100 01101100 01101111 00100000 01000010 01101001 01101110 01100001 01110010 01111001 00100000 01010111 01101111 01110010 01101100 01100100 00100000 00100001");
The test code for binaryAgent is the following:

var testsSuccesfullyExecuted = 0;
var testErrors = [];

TestBlock.forEach(function(item , index){
    if(binaryAgent(item.binary) == item.text){
        console.log("Test ${"+ index +"} passes");
        testsSuccesfullyExecuted++;
    }else{
        testErrors.push(index);
    }
});

if(testsSuccesfullyExecuted == TestBlock.length){
    console.log("Test suite succesfully executed with no errors");
}else{
    console.error("Test failed with : " + JSON.stringify(testErrors));
}

var TestBlock = [
    {
        binary: "01010010 01100101 01100001 01101100 00100000 01110000 01110010 01101111 01100111 01110010 01100001 01101101 01110011 00100000 01100100 01101111 01101110 00100111 01110100 00100000 01100101 01100001 01110100 00100000 01100011 01100001 01100011 01101000 01100101 00101110",
        text: "Real programs don't eat cache."
    },
    {
        binary: "010011010110111101110011011101  0000100000011100000111010101100010011011000110100101100011001000   000110010001101111011011010110000101101001011011100010000001110011011011110110011001110100011101110110000101110010011001010010000001101001011100110010000001100110011100100110010101100101001011000010000001100001011101000010000001101100011001010                         1100001011100110111010000100000011000010111010000100     000011001100110100101110010011100110   11101000010000001100111011011000110000101101110011000110110010100101110",
        text: "Most public domain software is free, at least at first glance."
    },
    {
        binary: "010101000110100     00110111101110011011001010010000001110111011010000110111100100000011001000110111 1001000000110111 00110111101110100001000000111010101101110011001000110010101110010011100110111010001100001011011100110010000100 00001010101011011100110100101111000001000000110000101110010011001010010000001100011011011110110111001100100011001010110110101101110011001010110  0100001000000111010001101111001000000111001001100101011010010110111001110110011001010110111001 110100 00100000011010010111010000101100001000000111000001101111011011110111001001101100011110010010111000100000001011010010110100100000010010000110010101101110011100100111100    10010000001010011011100000110010101101110011000110110010101110010",
        text: "Those who do not understand Unix are condemned to reinvent it, poorly. -- Henry Spencer"
    },
    {
        binary: "01000110010011110101001001010100 0101001001000001010011100010000001101001011100110010000001100110011011110111001000100000011100000110100101110000011001010010000001110011011101000111001001100101011100110111001100100000011001100111001001100101011000010110101101110011001000000110000101101110011001000010000001100011011100 1001111001011100110111010001100001011011000110110001101111011001110111001001100001011100000110100001111001001000000111011101100101011001010110111001101001011001010111001100101110",
        text: "FORTRAN is for pipe stress freaks and crystallography weenies."
    },
    {
        binary: "00101111 01100101 01100001 01110010 01110100 01101000 00100000 01101001 011100    11 00100000 00111001 00111000 00100101 00100000 01100110 01110101 01101100 01101  100 00100000 00101110 00101110 00101110 00100000 01110000 01101100 01100101 01100001 01110011 01100101 00100000 01100100 01100101 01101100 01100101 01110100 01100101 00100000 01100001 0110 1110 011110  01 01101111 01101110 01100101 00100000 01111001 01101111 01110101 00100000 01100011 01100001 01101110 00101110   ",
        text: "/earth is 98% full ... please delete anyone you can."
    }
];
##############################################################################################################

Wherefore art thou
Make a function that looks through an array of objects (first argument) and returns an array of all objects that have matching property and value pairs (second argument). Each property and value pair of the source object has to be present in the object from the collection if it is to be included in the returned array.

For example, if the first argument is [{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], and the second argument is { last: "Capulet" }, then you must return the third object from the array (the first argument), because it contains the property and its value, that was passed on as the second argument.

function whatIsInAName(collection, source) {
  // What's in a name?
  var arr = [];
  var bool;
  // Only change code below this line
console.log("####################");
  console.log(source);
collection.forEach(function(element){
  if(Object.keys(source).length<=Object.keys(element).length){
    
  bool=true;
  
  Object.keys(source).forEach(function(sourceKey){
    
    if(element.hasOwnProperty(sourceKey)&&bool){
      bool=false;
//     console.log("elementSourceKey: "+element[sourceKey]);
      if(element[sourceKey]==source[sourceKey]){
        console.log(element[sourceKey]+" : "+source[sourceKey]);
        bool = true;        
      }
    }else{
      bool=false;
    }
    
  });
    
  if(bool){
      arr.push(element);
  }}
});
 
  console.log(arr);
  // Only change code above this line
  return arr;
}

whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" });


//SOLUTION
//BASIC
// function whatIsInAName(collection, source) {
//   // "What's in a name? that which we call a rose
//   // By any other name would smell as sweet.”
//   // -- by William Shakespeare, Romeo and Juliet
//   var srcKeys = Object.keys(source);

//   // filter the collection
//   return collection.filter(function (obj) {
//     for(var i = 0; i < srcKeys.length; i++) {
//       if(!obj.hasOwnProperty(srcKeys[i]) || obj[srcKeys[i]] !== source[srcKeys[i]]) {
//         return false;
//       }
//     }
//     return true;
//   });
// }

//INTERMEDIATE
// function whatIsInAName(collection, source) {
//   var srcKeys = Object.keys(source);

//   return collection.filter(function (obj) {
//     return srcKeys.every(function (key) {
//       return obj.hasOwnProperty(key) && obj[key] === source[key];
//     });
//   });
// }

//ADVANCED
// function whatIsInAName(collection, source) {
//   var srcKeys = Object.keys(source);

//   // filter the collection
//   return collection.filter(function (obj) {
//     return srcKeys
//       .map(function(key) {
//         return obj.hasOwnProperty(key) && obj[key] === source[key];
//       })
//       .reduce(function(a, b) {
//         return a && b;
//       });
//   });
// }

whatIsInAName([{ first: "Romeo", last: "Montague" }, { first: "Mercutio", last: null }, { first: "Tybalt", last: "Capulet" }], { last: "Capulet" }) should return [{ first: "Tybalt", last: "Capulet" }].
whatIsInAName([{ "a": 1 }, { "a": 1 }, { "a": 1, "b": 2 }], { "a": 1 }) should return [{ "a": 1 }, { "a": 1 }, { "a": 1, "b": 2 }].
whatIsInAName([{ "a": 1, "b": 2 }, { "a": 1 }, { "a": 1, "b": 2, "c": 2 }], { "a": 1, "b": 2 }) should return [{ "a": 1, "b": 2 }, { "a": 1, "b": 2, "c": 2 }].
whatIsInAName([{ "a": 1, "b": 2 }, { "a": 1 }, { "a": 1, "b": 2, "c": 2 }], { "a": 1, "c": 2 }) should return [{ "a": 1, "b": 2, "c": 2 }].
##############################################################################################################

Everything Be True
Check if the predicate (second argument) is truthy on all elements of a collection (first argument).

Remember, you can access object properties through either dot notation or [] notation.

function truthCheck(collection, pre) {
  // Is everyone being true
  var temp =collection.filter(function(val){
    return val[pre];
  });
  console.log(temp);
  return collection.length==collection.filter(function(val){
    return val[pre];
  }).length;
}

truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");

//SOLUTION

Basic Code Solution:
Using for-in loop & hasOwnProperty

function truthCheck(collection, pre) {
  // Create a counter to check how many are true.
  var counter = 0;
  // Check for each object
  for (var c in collection) {
    // If it is has property and value is truthy
    if (collection[c].hasOwnProperty(pre) && Boolean(collection[c][pre])) {
      counter++;
    }
  }
  // Outside the loop, check to see if we got true for all of them and return true or false
  return counter == collection.length;
}

// test here
truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");
:rocket: Run Code35

Code Explanation:
First I create a counter to check how many cases are actually true.
Then check for each object if the value is truthy
Outside the loop, I check to see if the counter variable has the same value as the length of collection, if true then return true, otherwise, return false
Relevant Links
JS Loops8
Object.prototype.hasOwnProperty()35
:sunflower: Intermediate Code Solution:
Using Array.every()

function truthCheck(collection, pre) {
  return collection.every(function (element) {
    return element.hasOwnProperty(pre) && Boolean(element[pre]);
  });
}

// test here
truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");
:rocket: Run Code16

Code Explanation:
Uses the native “every” method to test whether all elements in the array pass the test.
This link will help Array.prototype.every()185
Relevant Links
JS Array.prototype.every()30
MDN Array.prototype.every()185
:rotating_light: Advanced Code Solution:

function truthCheck(collection, pre) {
  // Is everyone being true?
  return collection.every(obj => obj[pre]);
}

truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex");
:rocket: Run Code14

Code Explanation:
For every object in the collection array, check the truthiness of object’s property passed in pre parameter
Array#every method internally checks if the value returned from the callback is truthy.
Return true if it passes for every object. Otherwise, return false.

truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy", "sex": "male"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex") should return true.
truthCheck([{"user": "Tinky-Winky", "sex": "male"}, {"user": "Dipsy"}, {"user": "Laa-Laa", "sex": "female"}, {"user": "Po", "sex": "female"}], "sex") should return false.
truthCheck([{"user": "Tinky-Winky", "sex": "male", "age": 0}, {"user": "Dipsy", "sex": "male", "age": 3}, {"user": "Laa-Laa", "sex": "female", "age": 5}, {"user": "Po", "sex": "female", "age": 4}], "age") should return false.
truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true}, {"name": "FastFoward", "onBoat": null}], "onBoat") should return false
truthCheck([{"name": "Pete", "onBoat": true}, {"name": "Repeat", "onBoat": true, "alias": "Repete"}, {"name": "FastFoward", "onBoat": true}], "onBoat") should return true
truthCheck([{"single": "yes"}], "single") should return true
truthCheck([{"single": ""}, {"single": "double"}], "single") should return false
truthCheck([{"single": "double"}, {"single": undefined}], "single") should return false
truthCheck([{"single": "double"}, {"single": NaN}], "single") should return false
##############################################################################################################

Arguments Optional
Create a function that sums two arguments together. If only one argument is provided, then return a function that expects one argument and returns the sum.

For example, addTogether(2, 3) should return 5, and addTogether(2) should return a function.

Calling this returned function with a single argument will then return the sum:

var sumTwoAnd = addTogether(2);

sumTwoAnd(3) returns 5.

If either argument isn't a valid number, return undefined.

function addTogether() {
  var result;
  var temp = arguments[0];
  if(!isNaN(arguments[0])){
  if(arguments.length==2){
    if(typeof arguments[0]=="number" &&typeof arguments[1]=="number"){
    result = arguments[0]+arguments[1];  
    } 
  }else{
    return function(val){
      if(typeof val=="number"){
      return temp+val;
      }else{
        return result;
      }
    };
  }
  }
  return result;
}

addTogether(2,3);

//SOLUTION
function addTogether() {
  // Function to check if a number is actually a number
  // and return undefined otherwise.
  var checkNum = function(num) {
    if (typeof num !== 'number') {
      return undefined;
    } else
      return num;
  };

  // Check if we have two parameters, check if they are numbers
  // handle the case where one is not
  // returns the addition.
  if (arguments.length > 1) {
    var a = checkNum(arguments[0]);
    var b = checkNum(arguments[1]);
    if (a === undefined || b === undefined) {
      return undefined;
    } else {
      return a + b;
    }
  } else {
    // If only one parameter was found, returns a new function that expects two
    // Store first argument before entering the new function scope
    var c = arguments[0];

    // Check the number again, must be outside the function to about returning an object
    // instead of undefined.
    if (checkNum(c)) {
      // Return function that expect a second argument.
      return function(arg2) {
        // Check for non-numbers
        if (c === undefined || checkNum(arg2) === undefined) {
          return undefined;
        } else {
          // if numbers then add them.
          return c + arg2;
        }
      };
    }
  }
}

// test here
addTogether(2,3);
:rocket: Run Code98

Code Explanation:
First, I create a function with the sole purpose of checking if a number is actually a number and returns undefined if it is not. It uses typeof to check.
Check if we have two parameters, if so, then check if they are numbers or not using the checkNum function I created.
If they are not undefined then add them and return the addition. If they any of them is undefined then return undefined.
In the case that we only have one argument, then we return a new function that expects two parameters. For this we store the first argument before going into a new scope to avoid our arguments being overwritten.
Still inside the big else, we need to check the argument we saved, if it is a number then we return the function expecting a second argument.
Now inside the function we are returning, we have to check for non numbers again just as at the beginning using checkNum if undefined then return that, otherwise if numbers add them and return the addition.
Relevant Links
typeof427
arguments object191
:sunflower: Intermediate Code Solution:
function addTogether() {
  var args = new Array(arguments.length);
  //Storing the arguments in an array
  for(var i = 0; i < args.length; ++i) {
      args[i] = arguments[i];
    }
 //Check for the arguments length
 if(args.length == 2){
    //If there are two arguments,check for the type of both arguments
    //Use typeof to check the type of the argument(both should be numbers)
    if(typeof args[0] !== 'number' || typeof args[1] !=='number' ){
      return undefined;
      }
    return args[0]+args[1];
   }
 //When only one argument is provided
 if(args.length == 1){
     a= args[0];
     //Check the  argument using typeof 
    if(typeof a!=='number'){
        return undefined;
      }
    else{
       //Making use of closures 
       return function(b){
       //Checking the second argument 
         if(typeof b !=='number'){
           return undefined;
           }
         else
           return a+b;
          };
      }
    }
}

// test here
addTogether(2,3);
:rocket: Run Code30

Code Explanation:
First store the arguments in an array by creating an array using the constructor method.
Adds each argument to the new array.
Then check for the length of the new array as we need to know if we have enough or not.
Check for the type of the arguments using typeof as they both should be numbers.
Returns undefined if any of them is not a number, or returns the sum of them if they are.
If there was only one argument, we still check the type after storing it in a new variable and returning a new function or undefined.
Relevant Links
typeof427
arguments object191
:rotating_light: Advanced Code Solution:
//jshint esversion: 6
function addTogether() {
  var args = Array.from(arguments);
  return args.some(n => typeof n !== 'number') ? 
    undefined: 
    args.length > 1 ?
      args.reduce((acc, n) => acc += n, 0):
      (n) => typeof n === "number" ? 
        n + args[0]:
        undefined;
}

// test here
addTogether(2,3);
:rocket: Run Code43

Code Explanation:
First I iterate through the arguments and check for arguments that are not a number and return undefined
If it’s not I then check if the arguments length is above 1, if it is I sum the arguments using Array.prototype.reduce
Else I return a function that checks if the passed in argument is a number and sum it, if not return undefined

addTogether(2, 3) should return 5.
addTogether(2)(3) should return 5.
addTogether("http://bit.ly/IqT6zt") should return undefined.
addTogether(2, "3") should return undefined.
addTogether(2)([3]) should return undefined.
##############################################################################################################

https://smoothprogramming.com/jquery/explicitly-set-cache-false-jquery-ajax/
WHY YOU SHOULD EXPLICITLY SET CACHE = FALSE IN JQUERY AJAX
Posted by Hiral Patel | Oct 13, 2016 | jQuery | 0  |     

INTRODUCTION
AJAX is one of the best invention happened for user experience improvement. AJAX helps to dynamically manipulate content on user’s browser without reloading the webpage. Now days, it is very common to use AJAX in load/add/update/delete content from server to client’s machine.

SCENARIO
For all jQuery AJAX requests, default option is cache = true for all datatype except datatype = ‘script’ or ‘jsonp’. Different browser have different default policy on caching ajax requests. Consider below scenario to understand my point on why you should explicitly set cache=false in ajax request.

Step 1: Make an AJAX request to get existing student’s information from the server and show it in a form to modify.
Step 2: If a user update and saves students data, then make an AJAX request to update existing student’s data. Moreover perform Step 1 to ensure it fetches latest data from the server.

PROBLEM
In my case the problem was in Internet Explorer 11.0 on Windows 7. If a user performs Step 2 then also it was showing student’s information which was fetched in Step 1. The ugly part of the whole story is that the program was working right even on Internet Explorer 11.0 on Windows 10. This is very hard to find out on developer’s environment because no developer uses Internet Explorer and Windows 7 in today’s date. The reason behind the problem is because Internet Explorer was caching ajax requests from step 1. Caching was avoiding to make fresh ajax request to get latest student information from the server when a user performs step 2. The solution to above problem is to explicitly set cache = false.

METHOD 1 : USE AJAXSETUP TO SET CACHE=FALSE WHEN PAGE LOADS
ajaxSetup sets default values to all future ajax requests.

JavaScript
$(document).ready(function(){

    // Set cache = false for all jquery ajax requests.
    $.ajaxSetup({
        cache: false,
    });

}
METHOD 2 : SET CACHE=FALSE EXPLICITLY IN $.AJAX REQUEST
We can set cache=false in $.ajax option settings.

JavaScript
// Set cache = false for all jquery ajax requests.
$.ajax({
    url : "/rest/getStudents",
    method : "GET",
    cache : false
})
.done(function(data){
    console.log("Successfully fetched data.");
})
.fail(function(data){
    console.log("Error in fetching data");
})
METHOD 3 : SET CACHE=FALSE EXPLICITLY IN $.GET REQUEST
We can set cache=false in $.get option settings.

JavaScript
// Set cache = false for all jquery ajax requests.
$.get({
    url : "/rest/getStudents",
    cache : false
})
.done(function(data){
    console.log("Successfully fetched data.");
})
.fail(function(data){
    console.log("Error in fetching data");
})
METHOD 4 : APPENDING TIMESTAMP TO ALL AJAX REQUESTS
We can set timestamp as a querystring to all ajax requests. $.now() gives a number representing current time in microseconds.

JavaScript
// Set cache = false for all jquery ajax requests.
$.ajax({
    url : "/rest/getStudents?t="+$.now(),
    method : "GET",
})
.done(function(data){
    console.log("Successfully fetched data.");
})
.fail(function(data){
    console.log("Error in fetching data");
})
CONCLUSION
Developer should set cache=false to each ajax request to avoid catastrophic effect in production environment for support to legacy browsers and operating systems.
##############################################################################################################

Record Collection
You are given a JSON object representing a part of your musical album collection. Each album has several properties and a unique id number as its key. Not all albums have complete information.

Write a function which takes an album's id (like 2548), a property prop (like "artist" or "tracks"), and a value (like "Addicted to Love") to modify the data in this collection.

If prop isn't "tracks" and value isn't empty (""), update or set the value for that record album's property.

Your function must always return the entire collection object.

There are several rules for handling incomplete data:

If prop is "tracks" but the album doesn't have a "tracks" property, create an empty array before adding the new value to the album's corresponding property.

If prop is "tracks" and value isn't empty (""), push the value onto the end of the album's existing tracks array.

If value is empty (""), delete the given prop property from the album.

var collection = {
    "2548": {
      "album": "Slippery When Wet",
      "artist": "Bon Jovi",
      "tracks": [ 
        "Let It Rock", 
        "You Give Love a Bad Name" 
      ]
    },
    "2468": {
      "album": "1999",
      "artist": "Prince",
      "tracks": [ 
        "1999", 
        "Little Red Corvette" 
      ]
    },
    "1245": {
      "artist": "Robert Palmer",
      "tracks": [ ]
    },
    "5439": {
      "album": "ABBA Gold"
    }
};
// Keep a copy of the collection for tests
var collectionCopy = JSON.parse(JSON.stringify(collection));

// Only change code below this line
function updateRecords(id, prop, value) {
  console.log("#####################");
  if(collection[id]){
    if(collection[id][prop]){
      if(prop=="tracks"&&value){
          collection[id][prop].push(value);
      }else{
        if(!value){
          delete collection[id][prop];
        }
      }
    }else{
      console.log("no prop: "+prop);
      if(prop=="tracks"){
        collection[id][prop]=[value];
      }else{
       
      collection[id][prop]=value;}
    }
  }
  console.log(collection[id]);
  return collection;
}

// Alter values below to test your code
updateRecords(5439, "artist", "ABBA");

//SOLUTION 
Basic Code Solution:
function updateRecords(id, prop, value) {
  if (prop === "tracks" && value !== "") {
   if(collection[id][prop]) {
    collection[id][prop].push(value);
   }
   else {
    collection[id][prop]=[value];
   }
  } else if (value !== "") {
    collection[id][prop] = value;
  } else {
    delete collection[id][prop];
  }

  return collection;
}
:rocket: Run Code136

Code Explanation:
First checks if prop is equal to tracks AND if value isn't a blank string. If both tests pass, value is pushed into the tracks array.
If that first check doesn't pass, it next checks only if value isn't a blank string. If that test passes, either a new key (prop) and value (value) are added to the object, or an existing key is updated if the prop already exists.
If both these checks fail (meaning value must be an empty string), then the key (prop) is removed from the object.

After updateRecords(5439, "artist", "ABBA"), artist should be "ABBA"
After updateRecords(5439, "tracks", "Take a Chance on Me"), tracks should have "Take a Chance on Me" as the last element.
After updateRecords(2548, "artist", ""), artist should not be set
After updateRecords(1245, "tracks", "Addicted to Love"), tracks should have "Addicted to Love" as the last element.
After updateRecords(2468, "tracks", "Free"), tracks should have "1999" as the first element.
After updateRecords(2548, "tracks", ""), tracks should not be set
##############################################################################################################

Symmetric Difference
Create a function that takes two or more arrays and returns an array of the symmetric difference (? or ?) of the provided arrays.

Given two sets (for example set A = {1, 2, 3} and set B = {2, 3, 4}), the mathematical term "symmetric difference" of two sets is the set of elements which are in either of the two sets, but not in both (A ? B = C = {1, 4}). For every additional symmetric difference you take (say on a set D = {2, 3}), you should get the set with elements which are in either of the two the sets but not both (C ? D = {1, 4} ? {2, 3} = {1, 2, 3, 4}).

function sym(args) {
  var data = [];
  for(var i=0;i<arguments.length;i++){
    data.push(arguments[i]);
  }
  console.log(""+data);
  
  data=data.reduce(function(holder,val){
    console.log("HOLDER: "+holder);
    console.log("VAL: "+val);
    holder=arrRemoveDuplicates(holder);
    val=arrRemoveDuplicates(val);
    function arrRemoveDuplicates(arr){
      console.log("ARR: "+arr);
       for(var i=0;i<arr.length;i++){
      for(var k=i+1;k<arr.length;k++){
        if(arr[k]==arr[i]){
          console.log("arr[k]: "+arr[k]+" el: "+arr[i]);
        arr.splice(k,1);
          }
        }
      }
      console.log("ARRF: "+arr);
      return arr;
    }
    
    console.log("HOLDER: "+holder);
      for(var j=0;j<holder.length;j++){
        console.log("holder["+j+"] = "+holder[j]);
        if(val.includes(holder[j])){
          console.log("splice");
          var duplicateValue=holder[j];
          console.log("INDEX: "+j);
          holder.splice(j,1);
          val.splice(val.indexOf(duplicateValue),1);
          console.log(""+holder);
          console.log(""+val);
          console.log("======================================");
          j--;
        }
      }
    return holder.concat(val);
  });
  console.log("data: "+data);
  console.log("#######################################");
  return data;
}

sym([1, 2, 3], [5, 2, 1, 4]);

//SOLUTION
Basic Code Solution:
function sym() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
    }

    function symDiff(arrayOne, arrayTwo) {
        var result = [];

        arrayOne.forEach(function(item) {
            if (arrayTwo.indexOf(item) < 0 && result.indexOf(item) < 0) {
                result.push(item);
            }
        });

        arrayTwo.forEach(function(item) {
            if (arrayOne.indexOf(item) < 0 && result.indexOf(item) < 0) {
                result.push(item);
            }
        });

        return result;
    }

    // Apply reduce method to args array, using the symDiff function
    return args.reduce(symDiff);
}
:rocket: Run Code97

Code Explanation:
push() is used to break down the arguments object to an array, args.
The symDiff function finds the symmetric difference between two sets. It is used as a callback function for the reduce() method called on args.
arrayOne.forEach() pushes the elements to result which are present only in arrayOne as well as not already a part of result.
arrayTwo.forEach() pushes the elements to result which are present only in arrayTwo as well as not already a part of result.
The result, which is the symmetric difference is returned. This solution works for any number of sets.
Relevant Links
JS For Loops Explained1
array.length2
JS Array Prototype Push
JS Array Prototype ForEach7
JS Array Prototype IndexOf6
:sunflower: Intermediate Code Solution:
function sym() {

  // Convert the argument object into a proper array
  var args = Array.prototype.slice.call(arguments);

  // Return the symmetric difference of 2 arrays
  var getDiff = function(arr1, arr2) {

    // Returns items in arr1 that don't exist in arr2
    function filterFunction(arr1, arr2) {
      return arr1.filter(function(item) {
        return arr2.indexOf(item) === -1;
      });
    }

    // Run filter function on each array against the other
    return filterFunction(arr1, arr2)
      .concat(filterFunction(arr2, arr1));
  };

  // Reduce all arguments getting the difference of them
  var symarray = args.reduce(getDiff, []);

  // Run filter function to get the unique values
  var unique = symarray.filter(function(elem, index, self) {
    return index === self.indexOf(elem);
    });
  return unique;
}

// test here
sym([1, 2, 3], [5, 2, 1, 4]);
:rocket: Run Code28

Code Explanation:
The slice() method is used to break down the arguments object to an array, args.
The getDiff function finds the symmetric difference between two sets, arr1 and arr2. It is used as a callback function for the reduce() method called on args.
The first filterFunction() returns elements in arr1 that don’t exist in arr2.
The next filterFunction() is run on each array against the other to check the inverse of the first check for uniqueness and concatenate it.
symarray consists of the reduced arguments.
filter() is used on symarray to keep only the unique values and unique is returned.
Relevant Links
JS Array Prototype Slice5
JS Array Prototype Filter8
JS Array Prototype Concat3
:rotating_light: Advanced Code Solution:
function sym() {
  // difference between set A and set B
  const diff = (A, B) => new Set([...A].filter(n => !B.has(n)));
  // spread operator to convert array like object to array
  const result = [...arguments]
    // map elements in arguments (array) to Set
    .map(arr => new Set(arr))
    // using the formula in https://en.wikipedia.org/wiki/Symmetric_difference
    // i reduce it by uniting the diff(A, B) and diff(B, A)
    .reduce((acc, set) => new Set([...diff(acc, set), ...diff(set, acc)]));

  // convert the set to array by using spread operator again
  return [...result];
}

// test here
sym([1, 2, 3], [5, 2, 1, 4]);
:rocket: Run Code26

Code Explanation:
diff consists of the difference between set A and set B.
result holds the object which has been converted to an array using the spread operator.
map() is used to populate the new set object with elements from arr using the symmetric difference formula.
Before returning, the set is converted to an array using the spread operator.

sym([1, 2, 3], [5, 2, 1, 4]) should return [3, 4, 5].
sym([1, 2, 3], [5, 2, 1, 4]) should contain only three elements.
sym([1, 2, 5], [2, 3, 5], [3, 4, 5]) should return [1, 4, 5]
sym([1, 2, 5], [2, 3, 5], [3, 4, 5]) should contain only three elements.
sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]) should return [1, 4, 5].
sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]) should contain only three elements.
sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3]) should return [2, 3, 4, 6, 7].
sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3]) should contain only five elements.
sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1]) should return [1, 2, 4, 5, 6, 7, 8, 9].
sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1]) should contain only eight elements.
##############################################################################################################

	
The factorial function (symbol: !) just means to multiply a series of descending natural numbers. Examples:

4! = 4 ? 3 ? 2 ? 1 = 24
7! = 7 ? 6 ? 5 ? 4 ? 3 ? 2 ? 1 = 5.040
1! = 1
##############################################################################################################

No repeats please
Return the number of total permutations of the provided string that don't have repeated consecutive letters. Assume that all characters in the provided string are each unique.

For example, aab should return 2 because it has 6 total permutations (aab, aab, aba, aba, baa, baa), but only 2 of them (aba and aba) don't have the same letter (in this case a) repeating.

function permAlone(str) {
  if(str.length==1){
    return 1;
  }
  
  var difCheck=false;
  var tempChar=str.charAt(0);
  
  for(var j=0;j<str.length&&!difCheck;j++){
    if(str.charAt(0)!=str.charAt(j)){
    difCheck=true;
      }
    }     
   
  if(difCheck){
    var result=[];
    console.log("String: "+str);
    result = perm(str.split(""));
    console.log("result: "+result.length+" - "+result);  
    result = doublesSweeper(result); 
    console.log("result: "+result.length+" - "+result); 
    return result.length;
  }
    
  return 0;
}

function perm(array){
      
    if(array.length<2){
      return array;
      
    }else{
      var temp=[];
      
      for(var i=0;i<array.length;i++){
        var char=array[i];
        
        var remainingArray =    
            array.slice(0,i).concat(array.slice(i+1,array.length));
        
        perm(remainingArray).forEach(function(val){
        temp.push(char+val);
        });
        
      }   
      return temp;      
      }
    }

function doublesSweeper(arr){
  
  return arr.filter(function(val){
    var checker=true;
    for(var k=0;k<val.length-1&& checker;k++){
      if(val[k]==val[k+1]){
        checker = false;
      }
    }
    if(checker){
      return val;
    }
  });
}

permAlone('aab');

//useful
// javascript is call by value by default,
//// but when passing object it is passing the actual reference
//function swap(index1, index2, arr) {
//  var tmp;
  
//  tmp = arr[index1];
//  arr[index1] = arr[index2];
//  arr[index2] = tmp;
//}

//// check if characters repeat in string 
//function checkRepeats (str) {
//  var exp = /(\w)\1+/g;
//  return exp.test(str);
//}

// function permut(string) {
//     if (string.length < 2) return string; // This is our break condition

//     var permutations = []; // This array will hold our permutations

//     for (var i=0; i<string.length; i++) {
//         var char = string[i];

//         // Cause we don't want any duplicates:
//         if (string.indexOf(char) != i) // if char was used already
//             continue;           // skip it this time

//         var remainingString = string.slice(0,i) + string.slice(i+1,string.length); //Note: you can concat Strings via '+' in JS

//         for (var subPermutation of permut(remainingString))
//             permutations.push(char + subPermutation)

//     }
//     return permutations;
// }

// function *permute(a, n = a.length) {
//   if (n <= 1) yield a.slice();
//   else for (let i = 0; i < n; i++) {
//     yield *permute(a, n - 1);
//     const j = n % 2 ? 0 : i;
//     [a[n-1], a[j]] = [a[j], a[n-1]];
//   }
// }

// console.log(Array.from(permute("xyz".split(''))).map(perm => perm.join('')));


//SOLUTION
Another way to think about this problem is to start from an empty space. Introduce the first letter to the space. This space will now contain the first sub-permutation. Here’s a diagram illustrating the idea:

diagramzFm5gRx.png898x544 7.1 KB
Non-Recursive Method
// An approach to introduce a new character to a permutation
var ch = '?';
var source = ['?', '?', '?'];     // Current sub-permutation
var temp, dest = [];

for (var i = 0; i <= source.length; ++i) {
  temp = source.slice(0);         // Copy the array
  temp.splice(i, 0, ch);          // Insert the new character
  dest.push(temp);                // Store the new sub-permutation
}
Finding each permutation could then be done non-recursively by including the above in a function taking a source array and returning a destination array. For each letter of the input string, pass that character, as well as the array returned from the previous call of the function.

Basic Code Solution:
function permAlone(str) {

  // Create a regex to match repeated consecutive characters.
  var regex = /(.)\1+/g;

  // Split the string into an array of characters.
  var arr = str.split('');
  var permutations = [];
  var tmp;

  // Return 0 if str contains same character.
  if (str.match(regex) !== null && str.match(regex)[0] === str) return 0;

  // Function to swap variables' content.
  function swap(index1, index2) {
    tmp = arr[index1];
    arr[index1] = arr[index2];
    arr[index2] = tmp;
  }

  // Generate arrays of permutations using the algorithm.
  function generate(int) {
    if (int === 1) {
      // Make sure to join the characters as we create  the permutation arrays
      permutations.push(arr.join(''));
    } else {
      for (var i = 0; i != int; ++i) {
        generate(int - 1);
        swap(int % 2 ? 0 : i, int - 1);
      }
    }
  }

  generate(arr.length);

  // Filter the array of repeated permutations.
  var filtered = permutations.filter(function(string) {
    return !string.match(regex);
  });

  // Return how many have no repetitions.
  return filtered.length;
}

// Test here.
permAlone('aab');
:rocket: Run Code170

Code Explanation:
regex contains the regular expression to match repeated consecutive characters.
The string str is split into an array of characters, arr.
0 is returned if str contains same characters.
The function swap() is used for the purpose of swapping the contents of two variable’s contents.
The next block of code uses Heap’s algorithm to generate arrays of permutations in permutations.
The filtered variable filters permutations to include only non-repeated permutations.
filtered.length returns the number of total permutations of the provided string that don’t have repeated consecutive letters.
Relevant Links
JS String Prototype Split4
JS String Prototype Match7
JS Array Prototype Push1
JS Array Prototype Join2
JS For Loops Explained1
array.length3
JS Array Prototype Filter2
:rotating_light: 

And MORE 
This was INTENSE! By far the hardest algorithm so far I think… this one made me feel like an absolute novice.
After much deliberation ended up implementing a non-recursive version of Heap’s algorithm…

  let n = str.length
  let array = str.split('')
  let count = 0;

  let checkRepeats = (x) => {
  return  /(.)+\1/g.test(x.join('')) 
  }
  
  let c = [];
  for(let i = 0; i < n; i++){
    c[i] = 0
  }
  
  checkRepeats(array) ? null : count++
  
  let i = 0;
  while(i < n){
    if(c[i] < i){
      if(i % 2 == 0){
        [array[0], array[i]] = [array[i], array[0]]
      } else {
        [array[c[i]], array[i]] = [array[i], array[c[i]]]
      }
      checkRepeats(array) ? null : count++
      c[i] += 1
      i = 0
    } else {
      c[i] = 0
      i++
    }
  }
return count
}




More solutions

Another non-recursive solution using Heap's algorithm...
Code Explanation:: Read comments...

function permAlone(str){
  var strLen = str.length;
  var arr = str.split("");
  var c = [];
  var counter = 0;
  
  // Function to swap array's variables' content.
  function swap(idx1, idx2) {
    var tmp = arr[idx1];
    arr[idx1] = arr[idx2];
    arr[idx2] = tmp;
  };

  for (var i = 0; i < strLen; i ++){
      c[i] = 0;
  };

  //Check the 1st string for repeated consecutive characters.
  if (!/(.)\1+/g.test(str)) counter += 1;
  
  // Generate arrays of permutations using the Heap's non-recursive algorithm.
  //https://en.wikipedia.org/wiki/Heap%27s_algorithm
  var i = 0;
  while (i < strLen){
      if (c[i] < i){
        if (i % 2 === 0) swap(0, i);
          else swap(c[i], i);
        //Check repeated consecutive characters and increment the counter for unique strings.
        if (!/(.)\1+/g.test(arr.join(""))) counter += 1;
        c[i] += 1;
        i = 0;
      } else {
            c[i] = 0;
            i += 1;
        }
  }
  return counter;
}


And MORE

Here's mine, probably of no use regarding speed but it's nice and short. It's recursive but in a different way than suggested above.

function permAlone(str) {
  var re=/(.)\1/;
  function pT(p,o){
    if(o.length){
      var sum=0;
      for(var i=0;i<p.length+1;i++){
        sum+=pT(p.slice(0,i).concat(o[0]).concat(p.slice(i)),o.slice(1));
      }
      return sum;
    }
    else return !re.test(p.join(''));
  }
  return pT([],str.split(''));
}

And MORE

function permAlone(str) {
  //split the string into an array of letters
  return permNoRepeat(str.split("")).length;
}

function permNoRepeat(chars) {  
  //if 's' contains a single letter, return it
  if (chars.length === 1) {
    return chars;
  }  
  //here we will store all the permutations
  var p = [];
  
  //for every letter in the array
  for (var i = 0; i < chars.length; i++) {
    //create a copy of the array
    var temp = chars.slice();    
    //remove current letter from it
    temp.splice(i,1);
    
    //compute all the permutations of the remaining letters
    var perms = permNoRepeat(temp);
    
    //for each permutation, append the current letter and save it
    for (var j = 0; j < perms.length; j++) {
      //only keep it if the permutation does not start with the current letter
      //to get rid of duplicated consecutive letters 
      //so we append 'a' with 'ba' but not with 'ab'
      if (!perms[j].startsWith(chars[i])) {
        p.push(chars[i] + perms[j]);  
      }        
    }  
  }
  
  return p;  
}


Advanced Code Solution

Advanced Code Solution:
function permAlone(str) {
  if(str=='') return 1
  const bag=new Map()
  for(const c of str){
    bag.set(c,(bag.get(c)||0)+1)
  }
  const essence=[]
  for(let v of bag.values()){
    essence[--v]=(essence[v]||0)+1
  }
  let fact
  {const f=[1]
    fact= n=>f[n]||(f[n]=n*fact(n-1))
  }
  const essL=essence.length
  let bits=essL//essence.reduce((s,v)=>s+v,essL)
  let bExp=-1// essence as a bits expression
  let pFact=1, bMask=1
  for(let i=0;i<essL && bits<=32;i++){
    if(essence[i]==null) essence[i]=0
    const v=essence[i]; bits+=v
    pFact*= fact(i+1)**v * fact(v)
    bExp-=bMask; bMask<<=v+1
  }
  if(bits>32) 
    throw `Too many bits requiered: ${bits} >32`
  bExp+=bMask--
  // console.log(essence)
  // console.log(bExp.toString(2))

  class MapA extends Map{
    set(key, idx, value){
      if(value==null)
        return super.set(key, idx),this
      let ar=super.get(key)
      if(typeof ar!='object')
        {ar=[]; super.set(key, ar)}
      ar[idx]=value
      return this
    }
  }
  let crMap=new MapA()
  crMap.set((3<<bits-essL-1)-1, 0, 1)
  for(let lcrM=1;lcrM<str.length; lcrM++){
    const nxMap=new MapA()
    for(const [key, value] of crMap){
      const bDiff=key^bExp, 
        bnSprout=~((~key&bMask)>>>1 & key),
        bnImp=~bDiff&bnSprout,
        sum=value.reduce((s,v)=>s+v,0)
      let i=0, v=0, allowed=0
      for(let crBit=1;crBit&bMask;crBit<<=1){
        if(crBit&key) v++; else {i++; v=0}
        if(crBit&bnImp) continue
        cLabel:{
          if(crBit&bDiff)
            if(crBit&key)allowed++
            else allowed--
          else break cLabel
          if(crBit&bnSprout) continue
        }if(allowed)
          nxMap.set(key+crBit, i, i?v*sum-value[i-1]:sum)
      }
    }
    //could be done: recycle crMap
    crMap=nxMap;
  }
  return pFact*crMap.get(bExp).reduce((s,v)=>s+v,0)
}
:rocket: Run Code22

Code Explanation:
The problem asks to Return the number of total permutations not to generate them…Please follow my Gist for talk and explanations.
The problem asks to Return the number of total permutations not to generate them. Thus having as input 'abcde' it's well known that the solution is 5! = 1*2*3*4*5 = 120, it's not necessary to generate all 120 possibilities to find out the number 120. Warning: An advanced solution is more friendly with the computer and less with the developer / reviewer / maintainer / tester because of the high level of abstractness.

Let us have another example: 'abfdefa'. For this input I should have the same output as for 'abfdeaf' (swapping the last 2 letters) because the order of the input is meaningless. Knowing this we can extract a more meaning information: {a:2, b:1, f:2, d:1 e:1}

But what if I replace letter a with c, matters? Or if I swap e and f: 'cbedfce' getting {c:2, b:1, f:1, d:1 e:2}, should I get a different response? No. Thus the meaningful information about input is that I have 2 letters that occur twice each and 3 symbols that occur only once each, {1:3, 2:2} or [3,2]. As another example, [3,1,2] means a sequence of 3*1+1*2+2*3 = 11 symbols, 3 unique letters, 1 group of 2 identical letters and 2 groups, each of 3 letters like 'abcddeeefff'. Symbol d1 is different of symbol d2, but as letters are equal. And 'aaab' translates in [1,0,1] or in [1,0,1,0,0] but we will chose not to have 0 as the last element in list (array) for input but striving to get permAlone(input) we'll pass through temporary forms like [1,0,0] or [1,1,0] keeping their length as length of the goal ([1,0,1]).

I define distance of [a,b,c,..] as |[a,b,c,..]| = a+b*2+c*3+.. i.e. the length of the string which represents it.

Let's calculate recursively permAlone([a,b,c,..]). From this string we can choose as the first symbol any kind of letter. permAlone([a,b,c,..]) = a*permAlone([a-1,b,c,..]) + b*2*permAlone([a+,b-1,c,..]) + c*3*permAlone([a,b+,c-1,..]) +.. where [a,b+,c-1,..] is [a,b+1,c-1,..] but restricted to not use as a first symbol any symbol from a specific letter, that one that was of size 3 but now is of size 2. Therefore

permAlone([a,b+,c-1,..])
     = a*permAlone([a-1,b+1,c-1,..]) + b*2*permAlone([a+,b,c-1,..]) + (c-1)*3*permAlone([a,b+1+,c-2,..]) +..
     = permAlone([a,b+1,c-1,..]) - 2*permAlone([a+,b,c-1,..])
As you notice, for any string [a,b,c,..], permAlone([a,b,c,..]) is a combination of strings of length |[a,b,c,..]|-1. Also, but less obvious, permAlone([a,b,c,..]) is divided by a!*b!*pow(2!,b)*c!*pow(3!,c)*.. and permAlone([a,b+,c,..]) is divided by a!*b!*pow(2!,b+1)*c!*pow(3!,c)*..

Recursive proof:

permAlone([1,0,0]) = 1 which is divided by 1!*0!*pow(2!,0)*.. = 1
permAlone([a,b,c,..]) = a*X1*(a-1)!*b!*pow(2!,b)*c!*pow(3!,c)*.. + b*2*X2*a!*(b-1)!*pow(2!,b-1)*c!*pow(3!,c)*.. + c*3*X3*a!*b!*pow(2!,b+1)*(c-1)!*pow(3!,c-1)*.. =
. . = a!*b!*pow(2!,b)*c!*pow(3!,c)*.. * (X1+X2+X3+..)
permAlone([a,b+,c,..]) = permAlone([a,b+1,c,..]) - 2*permAlone([a+,b,c,..]) = X1*a!*(b+1)!*pow(2!,b+1)*c!*pow(3!,c)*.. - 2*X2*a!*b!*pow(2!,b)*c!*pow(3!,c)*.. =
. . = a!*b!*pow(2!,b+1)*c!*pow(3!,c)*.. * (X1*(b+1)-X2)
Knowing this let's make our live easier operating with a striped version of permAlone, named perm

permAlone([a,b,c,..])  = perm([a,b,c,..])  * a!*b!*pow(2!,b  )*c!*pow(3!,c)*..
permAlone([a,b+,c,..]) = perm([a,b+,c,..]) * a!*b!*pow(2!,b+1)*c!*pow(3!,c)*..
and

perm([a,b,c,..]) = perm([a-1,b,c,..]) + perm([a+,b-1,c,..]) + perm([a,b+,c-1,..]) +..
perm([a,b+,..])  = (b+1)*perm([a,b+1,..]) - perm([a+,b,..])
perm([a+,b,..])  = (a+1)*perm([a+1,b,..]) - perm([a ,b,..])
From here we can jump strait to code unless you think in imperative way and want to do more optimizations. My way of optimizing this is to start with the shortest string and step by step to generate and calculate viable forms toward my objective. From a string I can generate more in just one step, on every step increasing the number of strings but being careful not to generate dead end forms.

Let me explain myself by examples: let the target be [3,1,2]; I start with [1,0,0]. In step 2 I generate [2,0,0] and [0,1,0], both with distance 2. From this set of strings of length 2 I generate another one of length 3 (in step 3): [3,0,0] from [2,0,0], [1,1,0] from ([2,0,0] and [0,1,0]), [0,0,1] from [0,1,0]. I will call it sprouting, [2,0,0] sprouts [3,0,0] and a part of [1,1,0], [0,1,0] sprouts the other part of [1,1,0] and [0,0,1]

[3,0,0]->([4,0,0], [2,1,0]); [1,1,0]->([2,1,0], [0,2,0], [1,0,1]); [0,0,1]->([1,0,1], but not [0,0,0,1] because is dead end for me which I'm targeting [3,1,2])
[4,0,0]->([5,0,0], [3,1,0]); [2,1,0]->([3,1,0], [2,0,1]); [0,2,0]->([1,2,0], [0,1,1]); [1,0,1]->([2,0,1], [0,1,1])
...
... [1,3,0]->([2,3,0], [0,4,0], [1,2,1]); ...
... [1,2,1]->([2,2,1], [0,3,1], [1,1,2]); ...
...
...
[2,1,2]->([3,1,2] only); [4,0,2]->([3,1,2] only); [3,2,1]->([3,1,2] only)
[a,b,c] is viable iff c <= 2 and b+c <= 1+2 and a+b+c <= 3+1+2

It's like playing a game with an uni-dimensional board of 3 spaces and 6 pawns. On a space can be any number of pawns, stacked. On every turn I can place a pawn on the board, on the leftmost space or I can move one that's already on the board with one step to the right, promoting it on a higher position. The goal is to bring them in the [3,1,2] formation. Thus I can not pass through [0,4,0] position. I'm not able to demote any pawns, i.e. move it to the left.

But where are the restricted forms, those with + sign?, because I need them in the building of normal forms. I will use two maps, one already built (crMap) and one under construction (nxMap), with a normal form as keys and as corresponding value, an array of numbers, the perms of forms that compose the perm of key, first one normal and the other ones restricted. crMap.get([a,b,c,..])=[perm([a-1,b,c,..]), perm([a+,b-1,c,..]), perm([a,b+,c-1,..]), ..]. I keep only the values because I can figure out the form from key and position in array. If, let's say b is 0, [a+,b-1,c,..] don't exist and crMap.get([a,b,c,..])[1] stay undefined

Building nxMap: Let's suppose that we already know the set of keys of nxMap from crMap. I iterate on this set and for the key [a,b,c,..] I start building nxMap.get([a,b,c,..]):

perm([a-1,b,c,..])=sumOf(crMap.get([a-1,b,c,..]))
perm([a+,b-1,c,..])=(a+1)*perm([a+1,b-1,..]) - perm([a ,b-1,..])
    =(a+1)*sumOf(crMap.get([a+1,b-1,..])) - crMap.get([a+1,b-1,..])[0]
perm([a,b+,c-1,..])=(b+1)*perm([a,b+1,c-1,..]) - perm([a+,b,c-1,..])
    =(b+1)*sumOf(crMap.get([a,b+1,c-1,..])) - crMap.get([a,b+1,c-1,..])[1]
..
A way to build nxMap is to iterate on crMap and for every key in crMap to generate the keys for nxMap and for every new key of nxMap to build the appropriate value. But my way is to iterate on crMap keys and on its value. For every key and index i, I build nxMap.get(key+i)[i], where key+i is the key with key[i]-1 on position i and key[i+1]+1 on next position. The key is the extended form where key[0] is the number of pawns out the board.

Either way you choose you must have a map that see two keys equal by value, not by reference. In JavaScript only primitives? are compared by value. Hence I must find a translation of a key as an array of natural numbers to a number or if I need more memory, a string primitive. In my code I use a 32 bits int as key. For every space on board I have a 0 bit and for every pawn an 1 bit starting with the pawns out of the board. The lower bits have pawns of lower ranks. [1,3,0] is in reverse order 110101110 and right is 011101011. I used 3+6 bits.

In the sequence of bits I seek from right to left the 1 bit that is followed by a 0. These bits are candidates for promotion or places of key sprouting. In 011101011 the bits are 010001010. If my target is [3,1,2] -> 110101110, one candidate is not accepted, the bit in position 3. For bit 7 on the left of the key are 0 pawns (1 bit) but in target is 1. The bit 3 has 3 pawns as the target, to be accepted must have less than the target on the same position. The bit 1 has 4 and the target has 5.

Because any key and the target have the same number of 1 bits (6) I can count the bits from the right inclusive being 6 - no. 1 bits from the left exclusive. If the difference is 0 the candidate is not accepted.


permAlone("aab") should return a number.
permAlone("aab") should return 2.
permAlone("aaa") should return 0.
permAlone("aabb") should return 8.
permAlone("abcdefa") should return 3600.
permAlone("abfdefa") should return 2640.
permAlone("zzzzzzzz") should return 0.
permAlone("a") should return 1.
permAlone("aaab") should return 0.
permAlone("aaabb") should return 12.


##############################################################################################################

Make a Person
Fill in the object constructor with the following methods below:

getFirstName()
getLastName()
getFullName()
setFirstName(first)
setLastName(last)
setFullName(firstAndLast)
Run the tests to see the expected output for each method.

The methods that take an argument must accept only one argument and it has to be a string.

These methods must be the only available means of interacting with the object.

var Person = function(firstAndLast) {
 
// var firstAndLast=firstAndLast.split(" ")[0];
// var lastName=firstAndLast.split(" ")[1]; 
  var name=firstAndLast;
    // Complete the method below and implement the others similarly  
  
  this.getFirstName=function getFirstName(){
    console.log("get first: "+name.split(" ")[0]);
    return name.split(" ")[0];
  };
  
  this.getLastName=function(){
    console.log("get last: "+name.split(" ")[1]);
    return name.split(" ")[1];
  };
  this.getFullName=function(){
    console.log("get full: "+name);
    return name;
  };
  
  this.setFirstName=function(firstName){
    console.log("set first: "+firstName);
    name=firstName+" "+name.split(" ")[1];
    console.log(name);
  };
  
  this.setLastName=function(lastName){
    console.log("set last: "+lastName);
    console.log(name.split(" ")[0]);
    name=name.split(" ")[0]+" "+lastName;
    console.log(name);
  };
  
  this.setFullName=function(fullName){
    name=fullName;
  };
  console.log(name);
};

var bob = new Person('Bob Ross');
bob.getFullName();

//SOLUTION
// var Person = function(firstAndLast) {
//   let fullName;
  
//   this.setFullName = (full) => {fullName = full.split(' ');};
//   this.setFirstName = (first) => {fullName[0] = first;};
//   this.setLastName = (last) => {fullName[1] = last;};
  
//   this.setFullName(firstAndLast);
  
//   this.getFullName = () => fullName.join(' ');
//   this.getFirstName = () => fullName[0];
//   this.getLastName = () => fullName[1];
// };

Object.keys(bob).length should return 6.
bob instanceof Person should return true.
bob.firstName should return undefined.
bob.lastName should return undefined.
bob.getFirstName() should return "Bob".
bob.getLastName() should return "Ross".
bob.getFullName() should return "Bob Ross".
bob.getFullName() should return "Haskell Ross" after bob.setFirstName("Haskell").
bob.getFullName() should return "Haskell Curry" after bob.setLastName("Curry").
bob.getFullName() should return "Haskell Curry" after bob.setFullName("Haskell Curry").
bob.getFirstName() should return "Haskell" after bob.setFullName("Haskell Curry").
bob.getLastName() should return "Curry" after bob.setFullName("Haskell Curry").
##############################################################################################################


Map the Debris
Return a new array that transforms the element's average altitude into their orbital periods.

The array will contain objects in the format {name: 'name', avgAlt: avgAlt}.

You can read about orbital periods on wikipedia.

The values should be rounded to the nearest whole number. The body being orbited is Earth.

The radius of the earth is 6367.4447 kilometers, and the GM value of earth is 398600.4418 km3s

function orbitalPeriod(arr) {
  var GM = 398600.4418;
  var earthRadius = 6367.4447;
  var temp=[];
  arr.forEach(function(element){
   var result=0;     result=2*Math.PI*Math.sqrt(Math.pow(earthRadius+element.avgAlt,3)/GM);
    temp.push({name:element.name, orbitalPeriod:Math.round(result)});
    console.log("result: "+Math.round(result));
  });
  temp.forEach(function(val){
               console.log(val.name);
    console.log(val.orbitalPeriod);
               });
  console.log("temp: "+temp);
  return temp;
}

orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}]);

//SOLUTION

Basic Code Solution:
function orbitalPeriod(arr) {
  var GM = 398600.4418;
  var earthRadius = 6367.4447;
  var a = 2 * Math.PI;
  var newArr = [];
  var getOrbPeriod = function(obj) {
    var c = Math.pow(earthRadius + obj.avgAlt, 3);
    var b = Math.sqrt(c / GM);
    var orbPeriod = Math.round(a * b);
    delete obj.avgAlt;
    obj.orbitalPeriod = orbPeriod;
    return obj;
  };

  for (var elem in arr) {
    newArr.push(getOrbPeriod(arr[elem]));
  }

  return newArr;
}

// test here
orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}]);
:rocket: Run Code21

Code Explanation:
GM and earthRadius are both given to us.
To make the code easier to edit and read, each part of the equation is written separately.
Create newArr to store the orbPeriod's.
a is 2 times pi. The part that is a constant is on the global scope while the rest is part of a function.
Create a function, gerOrbPeriod() that will do the required work for any amount of objects.
c is (earthRadius + avgAlt) to the cube.
b is the square root of c divided by GM.
Create orbPeriod to store the product of a and b, with the Math.round() function applied to round up to the next whole number.
Then we delete the key avgAlt, and add the new key and its value.

Intermediate Code Solution:
function orbitalPeriod(arr) {
  var GM = 398600.4418;
  var earthRadius = 6367.4447;

  //Looping through each key in arr object
  for(var prop in arr) {
    //Rounding off the orbital period value
    var orbitalPer = Math.round(2 * Math.PI * Math.sqrt(Math.pow(arr[prop].avgAlt + earthRadius, 3) / GM));
    //deleting the avgAlt property
    delete arr[prop].avgAlt;
    //adding orbitalPeriod property
    arr[prop].orbitalPeriod = orbitalPer;
  }

  return arr;
}

// test here
orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}]);
:rocket: Run Code3

Code Explanation:
GM and earthRadius are both given to us.
A for..in loop is used to iterate through each value in given array arr.
orbitalPer holds the value of orbital period for each iteration calculated using the formula.
The key avgAlt is deleted, and orbitalPer found is assigned in arr.

Advanced Code Solution:
function orbitalPeriod(arr) {
  var GM = 398600.4418;
  var earthRadius = 6367.4447;

  // Loop through each item in the array arr
  arr.forEach(function(item) {
    // Calculate the Orbital period value
    var tmp = Math.round(2 * Math.PI * Math.sqrt(Math.pow(earthRadius + item.avgAlt, 3) / GM));
    //Delete the avgAlt property
    delete item.avgAlt;
    //Add orbitalPeriod property
    item.orbitalPeriod = tmp;
  });
  return arr;
}

// test here
orbitalPeriod([{name : "sputnik", avgAlt : 35873.5553}]);
:rocket: Run Code5

Code Explanation:
GM and earthRadius are both given to us.
The forEach() method is used to execute the function once per element (item) in arr.
tmp holds the value of orbital period for each element calculated using the formula.
The key avgAlt is deleted, and orbital period (tmp) found is assigned to the key orbitalPeriod.
##############################################################################################################


Pairwise
Given an array arr, find element pairs whose sum equal the second argument arg and return the sum of their indices.

If multiple pairs are possible that have the same numeric elements but different indices, return the smallest sum of indices. Once an element has been used, it cannot be reused to pair with another.

For example pairwise([7, 9, 11, 13, 15], 20) returns 6. The pairs that sum to 20 are [7, 13] and [9, 11]. We can then write out the array with their indices and values.

Index	0	1	2	3	4
Value	7	9	11	13	15
Below we'll take their corresponding indices and add them.

7 + 13 = 20 > Indices 0 + 3 = 3
9 + 11 = 20 > Indices 1 + 2 = 3
3 + 3 = 6 > Return 6

function pairwise(arr, arg) {
  console.log("##############");
//   var temp=[];
  var result=0;
  for(var i=0;i<arr.length;i++){
    for(var j=0;j<arr.length;j++){
      if(i!=j&&arr[i]+arr[j]===arg){
//         temp.push(i+j);
        result+=i+j;
//         console.log("i: "+i+" j: "+j+" temp: "+temp);
        arr[i]=NaN;
        arr[j]=NaN;
        i=0;
        j=0;
        console.log("arr: "+arr);
      }
    }
  }
//   var result=temp.reduce(function(holder,actual){return holder+actual;});
  console.log(result);
  return result;
}

pairwise([1,4,2,3,0,5], 7);
##############################################################################################################


Inventory Update
Compare and update the inventory stored in a 2D array against a second 2D array of a fresh delivery. Update the current existing inventory item quantities (in arr1). If an item cannot be found, add the new item and quantity into the inventory array. The returned inventory array should be in alphabetical order by item.

function updateInventory(arr1, arr2) {
    // All inventory must be accounted for or you're fired!
  console.log("#########################");
  for(var i=0;i<arr1.length;i++){
    for(var j=0;j<arr2.length;j++){
      if(arr1[i][1]===arr2[j][1]){
        arr1[i][0]=arr1[i][0]+arr2[j][0];
        arr2.splice(j,1);
//         console.log(" "+arr2);
      }
    }
  }
  var comparator=function(a,b){
    if(a[1]<b[1]){
      return -1;
    }
    if(a[1]>b[1]){
      return 1;
    }
    return 0;
  };
    return arr1.concat(arr2).sort(comparator);
}

// Example inventory lists
var curInv = [
    [21, "Bowling Ball"],
    [2, "Dirty Sock"],
    [1, "Hair Pin"],
    [5, "Microphone"]
];

var newInv = [
    [2, "Hair Pin"],
    [3, "Half-Eaten Apple"],
    [67, "Bowling Ball"],
    [7, "Toothpaste"]
];

updateInventory(curInv, newInv);

//SOLUTION

Basic Code Solution:
function updateInventory(arr1, arr2) {

    // Variable for location of product
    var index;

    // A helper method to return the index of a specified product (undefined if not found)
    var getProductIndex = function (name) {
        for (var i = 0; i < this.length; i++) {
            if (this[i][1] === name) {
                return i;
            }
        }
        return undefined;
    }

    // For each item of the new Inventory
    for (var i = 0; i < arr2.length; i++) {

        // Invoke our helper function using arr1 as this
        index = getProductIndex.call(arr1, arr2[i][1]);

        // If the item doesn't exist
        if (index === undefined) {
            // Push the entire item
            arr1.push(arr2[i]);
        } else {
            // Add the new quantity of the current item
            arr1[index][0] += arr2[i][0];
        }

    }

    // Sort alphabetically, by the product name of each item
    arr1.sort(function (a, b) {
        if (a[1] > b[1]) {
            return 1;
        }
        if (a[1] < b[1]) {
            return -1;
        }
        return 0;
    });

    return arr1;
}

// test here
// Example inventory lists
var curInv = [
    [21, "Bowling Ball"],
    [2, "Dirty Sock"],
    [1, "Hair Pin"],
    [5, "Microphone"]
];

var newInv = [
    [2, "Hair Pin"],
    [3, "Half-Eaten Apple"],
    [67, "Bowling Ball"],
    [7, "Toothpaste"]
];

updateInventory(curInv, newInv);
:rocket: Run Code31

Code Explanation:
The variable index stores the location (index) of a product.
The helper function getProductIndex() returns the index of a specified product. It iterates through each element of the array that it is called on until it can find the name parameter. If the product is not found in the inventory, undefined is returned.
Then, each item in the new inventory (delivery) is worked through:
index is set to the result of invoking the helper function i.e., search the new inventory for that product name and return it’s index.
If the item is found, quantity of the product is added to the quantity of the same product in current inventory.
If the item is not found, the entire product (name and quantity) is added to the current inventory.
The updated inventory, arr1, is then sorted by product name (held in arr1[x][1]).
The final - updated as well as sorted array is then returned.

function updateInventory(arr1, arr2) {
  // All inventory must be accounted for or you're fired!

  var index;
  var arrCurInvName = []; // Names of arr1's items
  var arrNeInvName = []; // Names of arr2's items

  // Same as using two for loops, this takes care of increasing the number of stock quantity.
  arr1.map(function(item1) {
    return arr2.map(function(item2) {
      if (item1[1] === item2[1]) {
        item1[0] = item1[0] + item2[0]; //Increase number of stock
      }
    });
  });

  // Get item's name for new Inventory
  arr2.map(function(item) {
    arrNeInvName.push(item[1]);
  });

  // Get item's name for Current Inventory
  arr1.map(function(item) {
    arrCurInvName.push(item[1]);
  });

  // Add new inventory items to current inventory.
  arrNeInvName.map(function(item) {
    if (arrCurInvName.indexOf(item) === -1) {
      index = arrNeInvName.indexOf(item);
      arr1.push(arr2[index]);
    }
  });

  // Sort the array alphabetically using the second element of the array as base.
  arr1.sort(function(currItem, nextItem) {

    //Ternary function to avoid using if else
    return currItem[1] > nextItem[1] ? 1 : -1;
  });

  return arr1;
}

// test here
// Example inventory lists
var curInv = [
    [21, "Bowling Ball"],
    [2, "Dirty Sock"],
    [1, "Hair Pin"],
    [5, "Microphone"]
];

var newInv = [
    [2, "Hair Pin"],
    [3, "Half-Eaten Apple"],
    [67, "Bowling Ball"],
    [7, "Toothpaste"]
];

updateInventory(curInv, newInv);
:rocket: Run Code10

Code Explanation:
The variable index stores the location (index) of a product.
arrCurInvName has the names of arr1’s items.
arrNeInvName has the names of arr2’s items.
arr1.map(function(item1)) takes care of items already existing in inventory i.e., it increases the quantity in the inventory.
Next, arr2.map(function(item)) and arr1.map(function(item)) get the names of items for the new and current inventory respectively.
arrNeInvName.map(function(item)) handles items which don’t already exist in inventory i.e., it adds new items to the inventory.
The updated array arr1 is then sorted alphabetically by product name (held in arr1[x][1]) and returned.

function updateInventory(arr1, arr2) {
  var flag = 0;
  arr2.forEach(function(item) {
    flag = 0;
    arr1.forEach(function(list) {
      // If the product is already present, increase the quantity
      if(item[1] === list[1]) {
        list[0] += item[0];
        flag = 1;
      }
    });
    //If not already present, add the product
    if(flag === 0)
      arr1.push(item);
  });

  //Return the sorted inventory in alphabetical order by product name
  return arr1.sort(function(a, b) {
    return a[1] > b[1] ? 1 : -1;
  });
}

// test here
// Example inventory lists
var curInv = [
    [21, "Bowling Ball"],
    [2, "Dirty Sock"],
    [1, "Hair Pin"],
    [5, "Microphone"]
];

var newInv = [
    [2, "Hair Pin"],
    [3, "Half-Eaten Apple"],
    [67, "Bowling Ball"],
    [7, "Toothpaste"]
];

updateInventory(curInv, newInv);
:rocket: Run Code10

Code Explanation:
The variable flag is a flag variable which checks whether a product exists in the inventory. A flag variable, in its simplest form, is a variable you define to have one value until some condition is true, in which case you change the variable’s value.
arr2.forEach(function(item)) iterates through each item in the new delivery:
If the product is already present, it’s quantity is simply updated and flag is made 1.
If the product is new i.e., flag is 0, it is added to the inventory using the push() method.
The updated array arr1 is then sorted alphabetically by product name.

The function updateInventory should return an array.
updateInventory([[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]], [[2, "Hair Pin"], [3, "Half-Eaten Apple"], [67, "Bowling Ball"], [7, "Toothpaste"]]).length should return an array with a length of 6.
updateInventory([[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]], [[2, "Hair Pin"], [3, "Half-Eaten Apple"], [67, "Bowling Ball"], [7, "Toothpaste"]]) should return [[88, "Bowling Ball"], [2, "Dirty Sock"], [3, "Hair Pin"], [3, "Half-Eaten Apple"], [5, "Microphone"], [7, "Toothpaste"]].
updateInventory([[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]], []) should return [[21, "Bowling Ball"], [2, "Dirty Sock"], [1, "Hair Pin"], [5, "Microphone"]].
updateInventory([], [[2, "Hair Pin"], [3, "Half-Eaten Apple"], [67, "Bowling Ball"], [7, "Toothpaste"]]) should return [[67, "Bowling Ball"], [2, "Hair Pin"], [3, "Half-Eaten Apple"], [7, "Toothpaste"]].
updateInventory([[0, "Bowling Ball"], [0, "Dirty Sock"], [0, "Hair Pin"], [0, "Microphone"]], [[1, "Hair Pin"], [1, "Half-Eaten Apple"], [1, "Bowling Ball"], [1, "Toothpaste"]]) should return [[1, "Bowling Ball"], [0, "Dirty Sock"], [1, "Hair Pin"], [1, "Half-Eaten Apple"], [0, "Microphone"], [1, "Toothpaste"]].
##############################################################################################################



##############################################################################################################



##############################################################################################################



##############################################################################################################



##############################################################################################################



##############################################################################################################

