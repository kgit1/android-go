Android Working with Recycler View
BY RAVI TAMADA  JANUARY 21, 2016 https://www.androidhive.info/2016/01/android-working-with-recycler-view/
Android RecyclerView is more advanced version of ListView with improved performance and other benefits. Using RecyclerView and CardView together, both lists and grids can be created very easily. Here is the complete information about RecyclerView and other examples.

In this tutorial we are going to learn how to render a simple RecyclerView with a custom layout. We’ll also learn writing a adapter class, adding list divider and row click listener. The recycler view we are going to design contains list of movies displaying the title, genre and year of release.

DOWNLOAD CODEDOWNLOAD .APK
Below is the RecyclerView widget with necessary attributes.

<android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:scrollbars="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
Before you start, make sure that you updated your Android Studio to latest version. Currently my Android Studio is updated to Android Studio 2.0 Preview 6.
1. Creating New Project

1. In Android Studio, go to File ? New Project and fill all the details required to create a new project. When it prompts to select a default activity, select Blank Activity and proceed.

2. Open build.gradle and add recycler view dependency. com.android.support:recyclerview-v7:23.1.1 and rebuild the project.

build.gradle
dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    testCompile 'junit:junit:4.12'
    compile 'com.android.support:appcompat-v7:23.1.1'
    compile 'com.android.support:design:23.1.1'
    compile 'com.android.support:recyclerview-v7:23.1.1'
}
3. With the latest version of build tools, Android Studio is creating two layout files for each activity. For main activity, it created activity_main.xml (contains CoordinatorLayout and AppBarLayout) and content_main.xml (for the actual content). Open content_main.xml and the recycler view widget.

content_main.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layout_behavior="@string/appbar_scrolling_view_behavior"
    tools:showIn="@layout/activity_main"
    tools:context=".MainActivity">
 
    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:scrollbars="vertical" />
 
</RelativeLayout>
4. Open colors.xml located under res ? values and add below colors.

colors.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#3F51B5</color>
    <color name="colorPrimaryDark">#303F9F</color>
    <color name="colorAccent">#FF4081</color>
    <color name="year">#999999</color>
    <color name="title">#222222</color>
</resources>
2. Writing the Adapter Class

After adding the RecyclerView widget, let’s start writing the adapter class to render the data. The RecyclerView adapter is same as ListView but the override methods are different.

5. Create a class named Movie.java and declare title, genre and year. Also add the getter/setter methods to each variable.

Movie.java
package info.androidhive.recyclerview;
 
public class Movie {
    private String title, genre, year;
 
    public Movie() {
    }
 
    public Movie(String title, String genre, String year) {
        this.title = title;
        this.genre = genre;
        this.year = year;
    }
 
    public String getTitle() {
        return title;
    }
 
    public void setTitle(String name) {
        this.title = name;
    }
 
    public String getYear() {
        return year;
    }
 
    public void setYear(String year) {
        this.year = year;
    }
 
    public String getGenre() {
        return genre;
    }
 
    public void setGenre(String genre) {
        this.genre = genre;
    }
}
6. Create an layout xml named movie_list_row.xml with the below code. This layout file renders a single row in recycler view by displaying movie name, genre and year of release.

movie_list_row.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:focusable="true"
    android:paddingLeft="16dp"
    android:paddingRight="16dp"
    android:paddingTop="10dp"
    android:paddingBottom="10dp"
    android:clickable="true"
    android:background="?android:attr/selectableItemBackground"
    android:orientation="vertical">
 
    <TextView
        android:id="@+id/title"
        android:textColor="@color/title"
        android:textSize="16dp"
        android:textStyle="bold"
        android:layout_alignParentTop="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
 
    <TextView
        android:id="@+id/genre"
        android:layout_below="@id/title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
 
    <TextView
        android:id="@+id/year"
        android:textColor="@color/year"
        android:layout_width="wrap_content"
        android:layout_alignParentRight="true"
        android:layout_height="wrap_content" />
 
</RelativeLayout>
7. Now create a class named MoviesAdapter.java and add the below code. Here onCreateViewHolder() method inflates movie_list_row.xml. In onBindViewHolder() method the appropriate movie data (title, genre and year) set to each row.

MoviesAdapter.java
package info.androidhive.recyclerview;
 
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
 
import java.util.List;
 
public class MoviesAdapter extends RecyclerView.Adapter<MoviesAdapter.MyViewHolder> {
 
    private List<Movie> moviesList;
 
    public class MyViewHolder extends RecyclerView.ViewHolder {
        public TextView title, year, genre;
 
        public MyViewHolder(View view) {
            super(view);
            title = (TextView) view.findViewById(R.id.title);
            genre = (TextView) view.findViewById(R.id.genre);
            year = (TextView) view.findViewById(R.id.year);
        }
    }
 
 
    public MoviesAdapter(List<Movie> moviesList) {
        this.moviesList = moviesList;
    }
 
    @Override
    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View itemView = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.movie_list_row, parent, false);
 
        return new MyViewHolder(itemView);
    }
 
    @Override
    public void onBindViewHolder(MyViewHolder holder, int position) {
        Movie movie = moviesList.get(position);
        holder.title.setText(movie.getTitle());
        holder.genre.setText(movie.getGenre());
        holder.year.setText(movie.getYear());
    }
 
    @Override
    public int getItemCount() {
        return moviesList.size();
    }
}
8. Now open MainActivity.java and do the below changes. Here prepareMovieData() method adds sample data to list view.

MainActivity.java
package info.androidhive.recyclerview;
 
import android.content.Context;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.Toolbar;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.View;
import android.widget.Toast;
 
import java.util.ArrayList;
import java.util.List;
 
public class MainActivity extends AppCompatActivity {
    private List<Movie> movieList = new ArrayList<>();
    private RecyclerView recyclerView;
    private MoviesAdapter mAdapter;
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
 
        recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
 
        mAdapter = new MoviesAdapter(movieList);
        RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getApplicationContext());
        recyclerView.setLayoutManager(mLayoutManager);
        recyclerView.setItemAnimator(new DefaultItemAnimator());
        recyclerView.setAdapter(mAdapter);
 
        prepareMovieData();
    }
 
    private void prepareMovieData() {
        Movie movie = new Movie("Mad Max: Fury Road", "Action & Adventure", "2015");
        movieList.add(movie);
 
        movie = new Movie("Inside Out", "Animation, Kids & Family", "2015");
        movieList.add(movie);
 
        movie = new Movie("Star Wars: Episode VII - The Force Awakens", "Action", "2015");
        movieList.add(movie);
 
        movie = new Movie("Shaun the Sheep", "Animation", "2015");
        movieList.add(movie);
 
        movie = new Movie("The Martian", "Science Fiction & Fantasy", "2015");
        movieList.add(movie);
 
        movie = new Movie("Mission: Impossible Rogue Nation", "Action", "2015");
        movieList.add(movie);
 
        movie = new Movie("Up", "Animation", "2009");
        movieList.add(movie);
 
        movie = new Movie("Star Trek", "Science Fiction", "2009");
        movieList.add(movie);
 
        movie = new Movie("The LEGO Movie", "Animation", "2014");
        movieList.add(movie);
 
        movie = new Movie("Iron Man", "Action & Adventure", "2008");
        movieList.add(movie);
 
        movie = new Movie("Aliens", "Science Fiction", "1986");
        movieList.add(movie);
 
        movie = new Movie("Chicken Run", "Animation", "2000");
        movieList.add(movie);
 
        movie = new Movie("Back to the Future", "Science Fiction", "1985");
        movieList.add(movie);
 
        movie = new Movie("Raiders of the Lost Ark", "Action & Adventure", "1981");
        movieList.add(movie);
 
        movie = new Movie("Goldfinger", "Action & Adventure", "1965");
        movieList.add(movie);
 
        movie = new Movie("Guardians of the Galaxy", "Science Fiction & Fantasy", "2014");
        movieList.add(movie);
 
        mAdapter.notifyDataSetChanged();
    }
}
Now if you run the app, you can see the movies displayed in a list manner.

android-recycler-view-example
3. Adding RecyclerView Divider / Separator

RecyclerView doesn’t have any divider related parameters to display the divider. Instead you need to extend a class from ItemDecoration and use addItemDecoration() method to display the divider.

9. Create a class named DividerItemDecoration.java and paste the below code.

DividerItemDecoration.java
package info.androidhive.recyclerview;
 
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.View;
 
/**
 * Created by Lincoln on 30/10/15.
 */
public class DividerItemDecoration extends RecyclerView.ItemDecoration {
 
    private static final int[] ATTRS = new int[]{
            android.R.attr.listDivider
    };
 
    public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL;
 
    public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL;
 
    private Drawable mDivider;
 
    private int mOrientation;
 
    public DividerItemDecoration(Context context, int orientation) {
        final TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(0);
        a.recycle();
        setOrientation(orientation);
    }
 
    public void setOrientation(int orientation) {
        if (orientation != HORIZONTAL_LIST && orientation != VERTICAL_LIST) {
            throw new IllegalArgumentException("invalid orientation");
        }
        mOrientation = orientation;
    }
 
    @Override
    public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) {
        if (mOrientation == VERTICAL_LIST) {
            drawVertical(c, parent);
        } else {
            drawHorizontal(c, parent);
        }
    }
 
    public void drawVertical(Canvas c, RecyclerView parent) {
        final int left = parent.getPaddingLeft();
        final int right = parent.getWidth() - parent.getPaddingRight();
 
        final int childCount = parent.getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = parent.getChildAt(i);
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            final int top = child.getBottom() + params.bottomMargin;
            final int bottom = top + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }
 
    public void drawHorizontal(Canvas c, RecyclerView parent) {
        final int top = parent.getPaddingTop();
        final int bottom = parent.getHeight() - parent.getPaddingBottom();
 
        final int childCount = parent.getChildCount();
        for (int i = 0; i < childCount; i++) {
            final View child = parent.getChildAt(i);
            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child
                    .getLayoutParams();
            final int left = child.getRight() + params.rightMargin;
            final int right = left + mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(c);
        }
    }
 
    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) {
        if (mOrientation == VERTICAL_LIST) {
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
        } else {
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
        }
    }
}
10. Open MainActivity.java and set the item decoration using addItemDecoration() method before setting the adapter.

recyclerView.addItemDecoration(new DividerItemDecoration(this, LinearLayoutManager.VERTICAL));
 
// set the adapter
recyclerView.setAdapter(mAdapter);
Now if you run the app, you should see a divider line separating each row.

android-recycler-view-separator-divider
4. Adding RecyclerView Item Click Listener

RecyclerView doesn’t have OnItemClickListener method too to identify item click. You need to write your own class extending RecyclerView.OnItemTouchListener.

11. Create a class named RecyclerTouchListener.java and extend it from RecyclerView.OnItemTouchListener. You can notice that ClickListener interface also added here.

RecyclerTouchListener.java
public interface ClickListener {
        void onClick(View view, int position);
 
        void onLongClick(View view, int position);
    }
 
    public static class RecyclerTouchListener implements RecyclerView.OnItemTouchListener {
 
        private GestureDetector gestureDetector;
        private MainActivity.ClickListener clickListener;
 
        public RecyclerTouchListener(Context context, final RecyclerView recyclerView, final MainActivity.ClickListener clickListener) {
            this.clickListener = clickListener;
            gestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {
                @Override
                public boolean onSingleTapUp(MotionEvent e) {
                    return true;
                }
 
                @Override
                public void onLongPress(MotionEvent e) {
                    View child = recyclerView.findChildViewUnder(e.getX(), e.getY());
                    if (child != null && clickListener != null) {
                        clickListener.onLongClick(child, recyclerView.getChildPosition(child));
                    }
                }
            });
        }
 
        @Override
        public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) {
 
            View child = rv.findChildViewUnder(e.getX(), e.getY());
            if (child != null && clickListener != null && gestureDetector.onTouchEvent(e)) {
                clickListener.onClick(child, rv.getChildPosition(child));
            }
            return false;
        }
 
        @Override
        public void onTouchEvent(RecyclerView rv, MotionEvent e) {
        }
 
        @Override
        public void onRequestDisallowInterceptTouchEvent(boolean disallowIntercept) {
 
        }
    }
Finally add the recycler view item click listener as mentioned below.

recyclerView.addOnItemTouchListener(new RecyclerTouchListener(getApplicationContext(), recyclerView, new RecyclerTouchListener.ClickListener() {
            @Override
            public void onClick(View view, int position) {
                Movie movie = movieList.get(position);
                Toast.makeText(getApplicationContext(), movie.getTitle() + " is selected!", Toast.LENGTH_SHORT).show();
            }
 
            @Override
            public void onLongClick(View view, int position) {
 
            }
        }));
Run the app and verify the item click. You should able to see a toast message upon clicking on a row. You can also notice that a background ripple effect when testing on lollipop device.

android-recycler-view-on-item-click-listener
Final Code

Below is the complete code of my MainActivity.java

MainActivity.java
package info.androidhive.recyclerview;
 
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.Toolbar;
import android.view.View;
import android.widget.Toast;
 
import java.util.ArrayList;
import java.util.List;
 
public class MainActivity extends AppCompatActivity {
    private List<Movie> movieList = new ArrayList<>();
    private RecyclerView recyclerView;
    private MoviesAdapter mAdapter;
 
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);
 
        recyclerView = (RecyclerView) findViewById(R.id.recycler_view);
 
        mAdapter = new MoviesAdapter(movieList);
 
        recyclerView.setHasFixedSize(true);
        RecyclerView.LayoutManager mLayoutManager = new LinearLayoutManager(getApplicationContext());
        recyclerView.setLayoutManager(mLayoutManager);
        recyclerView.addItemDecoration(new DividerItemDecoration(this, LinearLayoutManager.VERTICAL));
        recyclerView.setItemAnimator(new DefaultItemAnimator());
        recyclerView.setAdapter(mAdapter);
 
        recyclerView.addOnItemTouchListener(new RecyclerTouchListener(getApplicationContext(), recyclerView, new RecyclerTouchListener.ClickListener() {
            @Override
            public void onClick(View view, int position) {
                Movie movie = movieList.get(position);
                Toast.makeText(getApplicationContext(), movie.getTitle() + " is selected!", Toast.LENGTH_SHORT).show();
            }
 
            @Override
            public void onLongClick(View view, int position) {
 
            }
        }));
 
        prepareMovieData();
    }
 
    private void prepareMovieData() {
        Movie movie = new Movie("Mad Max: Fury Road", "Action & Adventure", "2015");
        movieList.add(movie);
 
        movie = new Movie("Inside Out", "Animation, Kids & Family", "2015");
        movieList.add(movie);
 
        movie = new Movie("Star Wars: Episode VII - The Force Awakens", "Action", "2015");
        movieList.add(movie);
 
        movie = new Movie("Shaun the Sheep", "Animation", "2015");
        movieList.add(movie);
 
        movie = new Movie("The Martian", "Science Fiction & Fantasy", "2015");
        movieList.add(movie);
 
        movie = new Movie("Mission: Impossible Rogue Nation", "Action", "2015");
        movieList.add(movie);
 
        movie = new Movie("Up", "Animation", "2009");
        movieList.add(movie);
 
        movie = new Movie("Star Trek", "Science Fiction", "2009");
        movieList.add(movie);
 
        movie = new Movie("The LEGO Movie", "Animation", "2014");
        movieList.add(movie);
 
        movie = new Movie("Iron Man", "Action & Adventure", "2008");
        movieList.add(movie);
 
        movie = new Movie("Aliens", "Science Fiction", "1986");
        movieList.add(movie);
 
        movie = new Movie("Chicken Run", "Animation", "2000");
        movieList.add(movie);
 
        movie = new Movie("Back to the Future", "Science Fiction", "1985");
        movieList.add(movie);
 
        movie = new Movie("Raiders of the Lost Ark", "Action & Adventure", "1981");
        movieList.add(movie);
 
        movie = new Movie("Goldfinger", "Action & Adventure", "1965");
        movieList.add(movie);
 
        movie = new Movie("Guardians of the Galaxy", "Science Fiction & Fantasy", "2014");
        movieList.add(movie);
 
        mAdapter.notifyDataSetChanged();
    }
 
}

====================================================================================================
////////////////////////////////////////////////////////////////////////////////////////////////////
====================================================================================================

Android RecyclerView Tutorial
Darryl Bayliss on June 16, 2016 https://www.raywenderlich.com/126528/android-recyclerview-tutorial


RecyclerView-feature
Recycling is one of those things that is good for the planet, and it’s an common sense way to make sure we don’t find ourselves buried in our own rubbish or without sufficient resources in the future.
A few Android engineers thought about the benefits of recycling and realized that an OS can also run more efficiently if it recycles. The result of this inspiration was millions of eco-Warriors and recycling enthusiasts rejoicing when the RecyclerView widget was introduced into Android Lollipop — or something like that. :]
There was even more celebration when Google announced a support library to make this clean, green, recycling machine backwards compatible all the way to Android Eclair (2.2), which was released back in 2010!
In this tutorial, you’re going to experience the power of RecyclerView in action and learn:
The purpose of a RecyclerView
The components that make up a RecyclerView
How to change the layout of a RecyclerView
How to add some nice animations to your RecyclerView
You’re also going to blast off into outer space with the sample app Galacticon. You’ll use it to build out a feed of daily astronomy photos from a public NASA API.
Prerequisites: You should have a working knowledge of developing for Android before working through this tutorial. If you need a refresher, take a look at some of our introductory tutorials!
Heading to Cape Canaveral: Getting Started
Download the starter project and open it up in Android Studio. There isn’t much to it yet, nor is the almighty RecyclerView anywhere to be seen.
Click the Run app button at the top and you’ll see something that resembles outer space in all the wrong ways:
1. Empty App
It’s empty, but that’s ok. You wouldn’t learn much if all the work was done for you! Before you can add that amazing astrophotography from NASA, you’ll need to do some set up work.
Obtaining The (API) Keys to the Shuttle
You’ll use the Astronomy Picture of the Day API, one of the most popular web services provided by NASA. To ensure it doesn’t fall victim to unsolicited traffic, the service requires you to have an API key to use it in an application.
Fortunately, getting a key is as simple as putting your name and email address into api.nasa.gov and copying the API key that appears on the screen or in the email you receive a few moments later:
3. API Key Email
Once you’ve acquired your API key, copy it and open the strings.xml file in your project. Paste your API key into the api_key string resource, replacing INSERT API KEY HERE:
4. API_KEY paste
Space Oddity: Learning About RecyclerView
You’re about to blast off into outer space to explore the vastness of RecyclerViews, but no competent commander heads into the unknown without preparation. You have questions, and you need answers before you go any further. Consider this section as your mission brief.
A RecyclerView can be thought of as a combination of a ListView and a GridView. However, there are extra features that separate your code into maintainable components even as they enforce memory-efficient design patterns.
But how could it be better than the tried and tested ListView and GridView you’re used to? Could it be some kind of alien technology? The answers, as always, are in the details.
Why You Need RecyclerView
Imagine you’re creating a ListView where the custom items you want to show are quite complicated. You take time to lovingly create a row layout for these items, and then use that layout inside your adapter.
Inside your getView() method, you inflate your new item layout. You then reference every view within by using the unique ids you provided in your XML to customize and add some view logic. Once finished, you pass that view to the ListView, ready to be drawn on the screen. All is well…or is it?
The truth is that ListViews and GridViews only do half the job of achieving true memory efficiency. They recycle the item layout, but don’t keep references to the layout children, forcing you to call findViewById() for every child of your item layout every time you call getView().
All this calling around can become very processor-intensive, especially for complicated layouts. Furthermore, the situation can cause your ListView scrolling to become jerky or non-responsive as it frantically tries to grab references to the views you need.
ListView-
Android engineers initially provided a solution to this problem on the Android Developers with smooth scrolling, via the power of the View Holder pattern.
When you use this pattern, you create a class that becomes an in-memory reference to all the views needed to fill your layout. The benefit is you set the references once and reuse them, effectively working around the performance hit that comes with repeatedly calling findViewById().
viewholder_new_larger
The problem is that it’s an optional pattern for a ListView or GridView. If you’re unaware of this detail, then you may wonder why your precious ListViews and GridViews are so slow.
First Contact: RecyclerView and Layouts
The arrival of the RecyclerView changed everything. It still uses an Adapter to act as a data source; however, you have to create ViewHolders to keep references in memory.
When you need a new view, it either creates a new ViewHolder object to inflate the layout and hold those references, or it recycles one from the existing stack.
Now you know why it’s called a RecyclerView!
Another perk of using RecyclerViews is that they come with default animations that you don’t have to create or add yourself — they just work.
Thanks to the requirement for a ViewHolder, the RecyclerView knows exactly which animation to apply to which item. Best of all, it just does it as required. You can even create your own animations and apply them as needed.
The last and most interesting component of a RecyclerView is its LayoutManager. This object positions the RecyclerView’s items and tells it when to recycle items that have transitioned off-screen.
Layout Managers come in three default flavors:
LinearLayoutManager positions your items to look like a standard ListView
GridLayoutManager positions your items in a grid format similar to a GridView
StaggerGridLayoutManager positions your items in a staggered grid format.
You can also create your own LayoutManagers to use with a RecyclerView if you want an extra bit of customization.
Hopefully that answers all your questions, commander. Now, onto the mission!
Preparing for Launch: Creating the RecyclerView
To create the RecyclerView, you’ll break the work into four parts:
Declare the RecyclerView in an activity layout and reference it in your activity Java file.
Create a custom item XML layout for your RecyclerView to use for its items.
Create the view holder for your view items, hook up the data source of the RecyclerView and handle the view logic by creating a RecyclerView Adapter.
Attach the adapter to the RecyclerView.
Step one should be familiar. Open up the activity_main.xml layout file, and add the following as a child of the LinearLayout:
<android.support.v7.widget.RecyclerView
  android:id="@+id/recyclerView"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:scrollbars="vertical"/>
Here you’re setting up the layout and telling the RecyclerView to match its parent.
Note: You’re using the v7 support library for backwards compatibility with older devices. The sample project already adds the RecyclerView Support Library as a dependency in your app’s build.gradle file. If you want more information on how to do it yourself, check out the Android developer website.
Open MainActivity.java and declare the following member variables at the top of the class:
private RecyclerView mRecyclerView;
private LinearLayoutManager mLinearLayoutManager;
In onCreate(), add the following lines after setContentView:
mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView);
mLinearLayoutManager = new LinearLayoutManager(this);
mRecyclerView.setLayoutManager(mLinearLayoutManager);
Phase one of ignition is complete! You’ve declared and allocated memory for two parts of the puzzle that RecyclerViews need to work: The RecyclerView and its Layout Manager.
Ignition Phase 2: Laying out the RecyclerView Items
Phase two of ignition involves creating a custom layout for the item you want your RecyclerView to use. It works exactly the same as it does when you create a custom layout for a ListView or Gridview.
Head over to your layout folder and create a new layout with the name recyclerview_item_row and set the root element as a LinearLayout. In your new layout, add the following XML elements as children of your LinearLayout:
<ImageView
  android:id="@+id/item_image"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_gravity="center"
  android:layout_marginTop="8dp"
  android:adjustViewBounds="true"
  android:layout_weight="3"/>
<TextView
  android:id="@+id/item_date"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_marginTop="8dp"
  android:layout_gravity="top|start"
  android:layout_weight="1"
  android:text="Some date"/>
<TextView
  android:id="@+id/item_description"
  android:layout_width="wrap_content"
  android:layout_height="wrap_content"
  android:layout_gravity="center|start"
  android:layout_weight="1"
  android:ellipsize="end"
  android:maxLines="5"/>
No rocket science here: You declared a few views as children of your layout, and can now use them in your adapter.
Adapters: Rocket Fuel for Your RecyclerView
Right-click on the com.raywenderlich.galacticon folder, select New \ Java Class, and name it RecyclerAdapter. At the top of the file below the package declaration, import the support library’s version of RecyclerView:
import android.support.v7.widget.RecyclerView;
Make the class extend RecyclerView.Adapter so it looks like the following:
public class RecyclerAdapter extends RecyclerView.Adapter<RecyclerAdapter.PhotoHolder> {
}
Android Studio will detect that you’re extending a class that has required methods and will underline your class declaration with a red squiggle.
To resolve this, click on the line of code to insert your cursor, then press alt + return (or option + return) to bring up a context menu. Select Implement Methods:
5. Implements RecyclerView adapter Methods
Confirm you want to implement the suggested methods by clicking OK:
6. Confirm RecyclerView Implementtion Methods
These methods are the driving force behind your RecyclerView adapter. Note how there is still a compiler error for the moment– this is because your adapter and the required methods are actually defined using your ViewHolder class, PhotoHolder, which doesn’t exist just yet. You’ll get to define your ViewHolder and see what each required method does shortly, so just hang tight, Commander!
As with every adapter, you need to provide the corresponding view a means of populating items and deciding how many items there should be.
Item clicks were previously managed by a ListView’s or GridView’s onItemClickListener. A RecyclerView doesn’t provide methods like this because it has one focus: ensuring the items inside are positioned properly and managed efficiently.
The job of listening for actions is now the responsibility of the RecyclerView item and its children. This may seem like more overhead, but in return, you get fine-grained control over how your item’s children can act.
At the top of your RecyclerAdapter class, add a variable to hold your photos:
private ArrayList<Photo> mPhotos;
Next, add a constructor to set it up:
public RecyclerAdapter(ArrayList<Photo> photos) {
  mPhotos = photos;
}
Nice job, Commander! Your adapter now knows where to look for data. Soon you’ll have an ArrayList of photos filled with the finest astrophotography!
Next, you’ll populate the stubbed methods that were added by Android Studio.
The first method, getItemCount(), is pretty simple and should be familiar from your work with ListViews or GridViews.
The adapter will work out how many items to display. In this case, you want the adapter to show every photo you’ve downloaded from NASA’s API. To do that, add the following line between the method braces:
return mPhotos.size();
Next, you’re going to exploit the ViewHolder pattern to make an object that holds all your view references.
Velcro For All: Keeping Hold Of Your Views
To create a PhotoHolder for your view references, you’ll create a static inner class for your adapter. You’ll add it here rather than in a separate class because its behavior is tightly coupled with the adapter.
It’s a static class, so regardless of how many instances you create, its values are shared amongst all of them — it’s pretty handy for holding references.
Add the following code underneath your adapter class member variables, but before any of the methods:
//1
public static class PhotoHolder extends RecyclerView.ViewHolder implements View.OnClickListener {
  //2
  private ImageView mItemImage;
  private TextView mItemDate;
  private TextView mItemDescription;
  private Photo mPhoto;

  //3
  private static final String PHOTO_KEY = "PHOTO";

  //4
  public PhotoHolder(View v) {
    super(v);

    mItemImage = (ImageView) v.findViewById(R.id.item_image);
    mItemDate = (TextView) v.findViewById(R.id.item_date);
    mItemDescription = (TextView) v.findViewById(R.id.item_description);
    v.setOnClickListener(this);
  }

  //5
  @Override
  public void onClick(View v) {
    Log.d("RecyclerView", "CLICK!");
  }
}
So what did you do here?
Made the class extend RecyclerView.ViewHolder, allowing it to be used as a ViewHolder for the adapter.
Added a list of references to the lifecycle of the object to allow the ViewHolder to hang on to your ImageView and TextView, so it doesn’t have to repeatedly query the same information.
Added a key for easier reference to the particular item being used to launch your RecyclerView.
Set up a constructor to handle grabbing references to various subviews of the photo layout.
Implemented the required method for View.OnClickListener since ViewHolders are responsible for their own event handling.
You should now be able to build and run the app again, but it’ll look about the same because you haven’t told the RecyclerView how to associate the PhotoHolder with a view.
Assembling The Pieces
Sometimes there are no ViewHolders available. In this scenario, RecylerView will ask onCreateViewHolder() from RecyclerAdapter to make a new one.
You’ll use the item layout — PhotoHolder — to create a view for the ViewHolder.
Replace the return null line between the curly braces with the following:
View inflatedView = LayoutInflater.from(parent.getContext())
    .inflate(R.layout.recyclerview_item_row, parent, false);
return new PhotoHolder(inflatedView);
Here you add the suggested LayoutInflater import. Then you inflate the view from its layout and pass it in to a PhotoHolder.
And with that, you’ve made it so the object holds onto those references while it’s recycled, but there are still more pieces to put together before you can launch your rocketship.
Start a new activity by replacing the log in ViewHolder’s onClick with this code:
Context context = itemView.getContext();
Intent showPhotoIntent = new Intent(context, PhotoActivity.class);
showPhotoIntent.putExtra(PHOTO_KEY, mPhoto);
context.startActivity(showPhotoIntent);
This grabs the current context of your item view and creates an intent to show a new activity on the screen, passing the photo object you want to show. Passing the context object into the intent allows the app to know what activity it is leaving.
Next thing to do is to add this method inside PhotoHolder:
public void bindPhoto(Photo photo) {
  mPhoto = photo;
  Picasso.with(mItemImage.getContext()).load(photo.getUrl()).into(mItemImage);
  mItemDate.setText(photo.getHumanDate());
  mItemDescription.setText(photo.getExplanation());
}
This binds the photo to the PhotoHolder, giving your item the data it needs to work out what it should show.
It also adds the suggested Picasso import, which is a library that makes it significantly simpler to get images from a given URL.
The last piece of the PhotoHolder assembly will tell it how to show the right photo at the right moment. It’s the RecyclerAdapter’s onBindViewHolder, and it lets you know a new item will be available on screen and the holder needs some data.
Add the following code inside the onBindViewHolder() method:
Photo itemPhoto = mPhotos.get(position);
holder.bindPhoto(itemPhoto);
Here you’re passing in a copy of your ViewHolder and the position where the item will show in your RecyclerView.
And that’s all you needed to do here on the assembly — just use the position where your ViewHolder will appear to grab the photo out of your list, and then pass it to your ViewHolder.
Step three of your ignition check protocol is complete!
Countdown And Liftoff: Hooking up the Adapter And RecyclerView
This is the moment you’ve been waiting for, the final stage before blast off! All you need to do is hook your adapter up to your RecyclerView and make sure it retrieves photos when it’s created so you can explore space — in pictures.
Open MainActivity.java, and add this variable at the top:
private RecyclerAdapter mAdapter;
Next, underneath the creation of your array list in onCreate() add the following:
mAdapter = new RecyclerAdapter(mPhotosList);
mRecyclerView.setAdapter(mAdapter);
Here you’re creating the adapter, passing in the constructors it needs and setting it as the adapter for your RecyclerView.
Although the adapter is connected, there’s one more thing to do to make sure you don’t have an empty screen.
In onStart(), underneath the call to super, add this code:
if (mPhotosList.size() == 0) {
  requestPhoto();
}
This adds a check to see if your list is empty, and if yes, it requests a photo.
Please sir, may I have more stars?
Next, in receivedNewPhoto(), update the method so it looks like the following:
@Override
public void receivedNewPhoto(final Photo newPhoto) {

  runOnUiThread(new Runnable() {
    @Override
    public void run() {
      mPhotosList.add(newPhoto);
      mAdapter.notifyItemInserted(mPhotosList.size());
    }
  });
}
Here you are informing the recycler adapter that an item was added after the list of photos was updated.
Now you’re ready to commence the ignition sequence, er…I mean run the app.
Run the app, load up the emulator and before long, Galacticon should look something like this:
7. RecyclerView Working
That’s not all. Tap on the photo, and you should be greeted with a new activity that brings that item into focus:
8. Focus Activity
But that’s still not all! Try rotating your device or emulator (function + control + F11/F12) and you’ll see the image in full screen glory!
9. Landscape focus
Depending on the size of the image and your device screen it may look a little distorted, but don’t worry about that.
Congratulations! You have a working RecyclerView and can take your journey amongst the stars.
Taking A Spacewalk: Adding Scrolling support
If you head back to MainActivity on your device and try to scroll down, you’ll notice something is amiss — your RecyclerView isn’t retrieving any new photos.
10. Scrolling Not Working
Your RecyclerView is doing exactly as it’s told by showing the contents of mPhotosList. The problem is that the app will only retrieve one photo when you load the app. It has no idea when or how to grab more photos.
So next, you’ll retrieve the number of the photos and the last visible photo index while scrolling. Then you’ll check to see if the last photo is visible and if there are no photos already on request. If these are both true, then your app goes away and downloads more pretty photos!
This patch will require a spacewalk, so break out your spacesuit and get ready for a zero gravity experience.
In MainActivity.java, add this method below onStart:
private int getLastVisibleItemPosition() {
  return mLinearLayoutManager.findLastVisibleItemPosition();
}
This uses your RecyclerView’s LinearLayoutManager to get the index of the last visible item on the screen.
Next, you add a method that inserts an onScrollListener to your RecyclerView, so it can get a callback when the user scrolls:
private void setRecyclerViewScrollListener() {
  mRecyclerView.addOnScrollListener(new RecyclerView.OnScrollListener() {
    @Override
    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
      super.onScrollStateChanged(recyclerView, newState);
      int totalItemCount = mRecyclerView.getLayoutManager().getItemCount();
      if (!mImageRequester.isLoadingData() && totalItemCount == getLastVisibleItemPosition() + 1) {
        requestPhoto();
      }
    }
  });
}
Now the RecyclerView has a scroll listener attached to it that is triggered by scrolling. During scrolling, the listener retrieves the count of the items in its LayoutManager and calculates the last visible photo index. Once done, it compares these numbers (incrementing the index by 1 because the index begins at 0 while the count begins at 1). If they match and there are no photos already on request, then you request a new photo.
Finally, hook everything to the RecyclerView by calling this method from onCreate, just beneath where you set your RecyclerView Adapter:
setRecyclerViewScrollListener();
Hop back in the ship (build and run the app again). Scroll down and you should see quite an improvement!
11. Scrolling Update
Excellent work, your RecyclerView now updates to show the latest photo requested by your app. The great thing is that receivedNewPhoto() handles most of the work because you told it to notify your adapter about new items.
That earns an intergalactic thumbs up for upcycling code!
Layout Changes
Now that your RecyclerView is up and running, it’s time to trick out your spaceship.
Wouldn’t it be cool if your RecyclerView could change its layout? Good news: RecyclerView’s item positioning is separated into a layout manager.
Add a variable for a GridLayoutManager to the top of MainActivity.java:
private GridLayoutManager mGridLayoutManager;
Note that this is a default LayoutManager, but it could just as easily be custom.
In onCreate(), initialize the LayoutManager below the existing Linear Layout Manager:
mGridLayoutManager = new GridLayoutManager(this, 2);
Just like you did with the previous LayoutManager, you pass in the context the manager will appear in, but unlike the former, it takes an integer parameter. In this case, you’re setting the number of columns the grid will have.
Add this method to MainActivity:
private void changeLayoutManager() {
  if (mRecyclerView.getLayoutManager().equals(mLinearLayoutManager)) {
    //1
    mRecyclerView.setLayoutManager(mGridLayoutManager);
    //2
    if (mPhotosList.size() == 1) {
      requestPhoto();
    }
  } else {
    //3
    mRecyclerView.setLayoutManager(mLinearLayoutManager);
  }
}
This code checks to see what LayoutManager your RecyclerView is using, and then:
If it’s using the LinearLayoutManager, it swaps in the GridLayoutManager
It requests a new photo if your grid layout only has one photo to show
If it’s using the GridLayoutManager, it swaps in the LinearLayoutManager
Next, you need to make some changes to getLastVisibleItemPosition() to help it handle the new LayoutManager. Replace its current contents with the following:
int itemCount;

if (mRecyclerView.getLayoutManager().equals(mLinearLayoutManager)) {
  itemCount = mLinearLayoutManager.findLastVisibleItemPosition();
} else {
  itemCount = mGridLayoutManager.findLastVisibleItemPosition();
}

return itemCount;
Here you ask the RecyclerView to tell you what its LayoutManager is, then you ask that LayoutManager to tell you the position of the last visible item.
To use the grid layout, make use of the Options menu button that is already available in the app. Add the following code underneath onStart():
@Override
public boolean onOptionsItemSelected(MenuItem item) {
  if (item.getItemId() == R.id.action_change_recycler_manager) {
    changeLayoutManager();
    return true;
  }
  return super.onOptionsItemSelected(item);
}
This checks the ID of the item tapped in the menu, then works out what to do about it. In this case, there should only be one ID that will match up, effectively telling the app to go away and rearrange the RecyclerView’s LayoutManager.
And just like that, you’re ready to go! Load up the app and tap the button at the top right of the screen, and you’ll begin to see the stars shift:
12. Grid Layout
Star Killer
Sometimes you’ll see things you just don’t like the look of, perhaps a galaxy far, far away that has fallen to the dark side or a planet that is prime for destruction. How could you go about killing it with a swipe?
Luckily, Android engineers have provided a useful class named ItemTouchHelper that gives you easy swipe behavior. Creating and attaching this to a RecyclerView requires just a few lines of code.
In MainActivity.java, underneath setRecyclerViewScrollListener() add the following method:
private void setRecyclerViewItemTouchListener() {

  //1
  ItemTouchHelper.SimpleCallback itemTouchCallback = new ItemTouchHelper.SimpleCallback(0, ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT) {
    @Override
    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder viewHolder1) {
      //2
      return false;
    }

    @Override
    public void onSwiped(RecyclerView.ViewHolder viewHolder, int swipeDir) {
      //3
      int position = viewHolder.getAdapterPosition();
      mPhotosList.remove(position);
      mRecyclerView.getAdapter().notifyItemRemoved(position);
    }
  };

  //4
  ItemTouchHelper itemTouchHelper = new ItemTouchHelper(itemTouchCallback);
  itemTouchHelper.attachToRecyclerView(mRecyclerView);
}
Let’s go through this step by step:
You create the callback and tell it what events to listen for. It takes two parameters, one for drag directions and one for swipe directions, but you’re only interested in swipe, so you pass 0 to inform the callback not to respond to drag events.
You return false in onMove because you don’t want to perform any special behavior here.
onSwiped is called when you swipe an item in the direction specified in the ItemTouchHelper. Here, you request the viewHolder parameter passed for the position of the item view, then you remove that item from your list of photos. Finally, you inform the RecyclerView adapter that an item has been removed at a specific position.
You initialize the ItemTouchHelper with the callback behavior you defined, and then attach it to the RecyclerView.
Add the method to the activity’s onCreate(), underneath setRecyclerViewScrollListener():
setRecyclerViewItemTouchListener();
This will attach the ItemTouchListener to the RecyclerView using the code you just wrote.
Run the app once more and swipe across one of your items, you should see it begin to move. If you swipe the item far enough, you should see it animate and vanish. If other items are visible, then they will reorganize themselves to cover the hole. How cool is that?
13 Swipe Away Item
Where To Go From Here?
yeti holding videos
Want to learn even faster? Save time with our
video courses
Nice job! You’ve been on quite an adventure, but now it’s time to head back to Earth and think about what you’ve learned.
You’ve created a RecyclerView and all the components it needs, such as a LayoutManager, an adapter and a ViewHolder.
You’ve updated and removed items from an Adapter.
You’ve added some cool features like changing layouts and adding swipe functionality.
Above all, you’ve experienced how separation of components — a key attribute of RecyclerViews — provides so much functionality with such ease. If you want your collections to be flexible and provide some excitement, then look no further than the all-powerful RecyclerView.
The final project for this tutorial is available here.
If you want to learn more about RecyclerViews then check out the Android documentation to see what it can do. Take a look at the support library for RecyclerViews to learn how to use it on older devices. If you want to make them fit with the material design spec then check out the list component design specification.
Join us in the forums to discuss this tutorial and your findings as you work with RecylerViews!
Until next time, space traveler!

====================================================================================================
////////////////////////////////////////////////////////////////////////////////////////////////////
====================================================================================================

https://medium.com/wolox-driving-innovation/the-good-the-bad-and-the-ugly-things-about-the-new-recyclerview-1795df6f94c9
The Good, the Bad and the Ugly Things About the New RecyclerView

What it is and what it is not
If you are an Android developer, no doubt you know that ListView is one of the most popular Android widgets. Its functionality and usage has no equal amongst its peers… until now.
Android Lollipop (API 21) introduced the new RecyclerView widget, with the intention of increasing ListView functionalities and taking them to the next level. Bear in mind that what Google purposely did with RecyclerView was to extend rather than to replace ListView functionalities and responsibilities. So, if you want to update your old and reliable ListView with the new state-of-the-art RecyclerView, you should know that it is possible, but not without some gotchas in the middle.
There is only one word that describes RecyclerView perfectly: flexibility. By decoupling the data from its visual representation, this widget can be used for many different purposes and provides the developer with a powerful tool.
Components


Related post: Sir, here is a handcrafted RecyclerView for you
Almost vintage retrocompatibility
RecyclerView has super retrocompatibility. This is because it is part of Android’s v7 Support Libraries. This means that any device running on API 7 or higher will be able to use RecyclerView right away.
The easiest way to get RecyclerView in your project is by using Gradle:
dependencies {
    ...
    compile 'com.android.support:recyclerview-v7:21.0.+'
}

And on your XML layout:
<android.support.v7.widget.RecyclerView
        android:id="@+id/recyclerView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

Boost your app with the ViewHolder pattern
RecyclerView forces you to use the ViewHolder pattern. To cut a long story short, this pattern holds references to views to avoid UI lookups as much as possible. In other words, instead of calling the method findViewById(…) each time you need to modify something from the UI, you just need to execute this method once and then save a reference to its result for future usage.
This results in a greater memory consumption (remember that you are using memory to keep the view’s references), but you also get a general improvement in the performance by not executing UI lookups anymore, which is a relatively expensive method (it is way faster to access an instance variable instead). This is where RecyclerView got its name from: recycling (reusing) view’s references.
However, don’t expect any miracles from the ViewHolder pattern. It does, indeed, give a performance boost to your app, but it will be much more evident on older (or low-end) devices. Generally speaking, powerful devices usually work fine with both ListViews and RecyclerViews.
Important: the ViewHolder pattern can also be used with ListViews and its performance impact will be the same. The only difference is that if you use RecyclerView, you must implement this pattern, while in ListViews this is an optional, but recommended technique.
Be flexible like chewing gum with LayoutManagers
The first big difference that we found in RecyclerView is that even though its purpose in life is to represent a given dataset graphically (just like any ListView), it does not necessarily need to be in a list of rows. RecyclerView has some tools (called LayoutManagers) that will help you achieve not only a list of rows, but also, grids and staggered grids of views.
For a ListView styled RecyclerView use the LinearLayoutManager
For a GridView styled RecyclerView use the GridLayoutManager
For a staggered grid effect, use the StaggeredGridLayoutManager
For a custom layout manager, extend the RecyclerView.LayoutManager class
For instance:
mActivity = getActivity();
mRecyclerView = (RecyclerView) mActivity.findViewById(R.id.recycler_view);
mLinearLayoutManager = new LinearLayoutManager(mActivity.getApplicationContext());
mRecyclerView.setLayoutManager(mLinearLayoutManager);

Even with LayoutManagers, there will be cases where you need to have more than one layout per item at the same time. Check out Part II of this post to learn how to manage these situations efficiently.

Related post: Every rose has its thorns
One Adapter to rule them all
Instead of having different adapters according to where the dataset comes from (like ArrayAdapter or CursorAdapter in ListView), RecyclerView uses a universal adapter implemented by you to handle the data sources. This reflects RecyclerView’s flexibility once again.
Make sure to extend RecyclerView.Adapter<RecyclerView.ViewHolder> and implement the following methods according to your views and dataset:
onCreateViewHolder(…)
onBindViewHolder(…)
getItemCount(…)
Pixar grade animations
If you are looking for a way to make the latest Toy Story animation movie then RecyclerView may not be your first choice. But, if you want to animate items such as adding, removing or swiping gestures, then RecyclerView may be useful for you.
The RecyclerView widget has out of the box support for custom animations by extending the ItemAnimator class.
A fade animation is applied by default. Besides, you can explicitly do this with:
mRecyclerView.setItemAnimator(new DefaultItemAnimator());
If you are looking for some already prepared animations for your RecyclerView you can use this library by Gabriele Marrioti.

Check out the second part of the post to learn some click listeners, layouts and performance tips and tricks!
Click here to read Part 2
Posted by Juan Ignacio Molina (juan.molina@wolox.com.ar)
www.wolox.com.ar
=======================================

Sir, Here is a Handcrafted RecyclerView for You
On the one hand, ListView had a pretty straightforward way to handle click events, all you had to do was to implement the OnItemClickListener() method. That was it.
On the other hand, RecyclerView is much more flexible but demanding. You have to implement the click listeners by yourself. Don’t panic, this is neither a bad nor a hard thing to do. The idea is to allow you to customize this behavior according to your needs, in case you want to use a grid instead of a list, for example.

Related post: The Good, the Bad and the Ugly Things About the New RecyclerView
Currently there are several ways of handling click events:
Implement the listeners in the Activity or Fragment
Implement the listeners in your RecyclerView Adapter
Implement the listeners in your item’s ViewHolder class
Here is an example of how to implement this according to the most upvoted answer in Stackoverflow regarding click events on RecyclerView.
RowViewHolder.java:
RecylerViewAdapter.java:
Using different layouts
One of the great things about RecyclerView is that it can handle different layouts for its items. Doing so will be responsibility of the Adapter.
Below, you will see the code used to create a loader item’s layout (based on the best answer in Stackoverflow).
RecylerViewAdapter.java:

Related post: Every Rose has its Thorns
Additional notes
Setting recyclerView.setHasFixedSize(true); optimizes the Recycler if changes in the adapter content cannot change the size of RecyclerView itself. Set this true if you don’t need to dynamically change your Recycler’s size.
RecyclerView does not come with default dividers. With ListViews you can set a default divider for the rows by using the XML attributes android:divider and android:dividerHeight. For RecyclerViews you can place the dividers in your item’s layout, code a custom implementation of RecyclerView.ItemDecoration or decide not to use dividers at all.
By now you probably have an idea of how the RecyclerView works and how to get the most from it. Despite of this, there are some things left to say about this widget that may raise some red flags.
============================


Every Rose has its Thorns
It’s undeniable that being a brand new widget, RecyclerView has some downsides that need to be addressed in the short/mid term, most probably in the shape of new open source libraries.
Multiple selection
One of these downsides is the single or multiple selection UI pattern. This feature has been covered extensively in ListViews, but ViewHolder does not include any tool for implementing selection.
If you want to use this UI pattern, ask yourself if using a RecyclerView will add significant value to your app because unfortunately the solution to this issue is not so simple.
Luckily for us, Bill Phillips from Big Nerd Ranch has found a nice workaround to get the multiple selection working. You can find his solution here.

Related post: The Good, the Bad and the Ugly Things About the New RecyclerView
Headers and footers
It would have been nice to have native support for headers and footers in RecyclerView. However, we are facing here another use case in which we need to rely on third party libraries to achieve this.
Obviously, you can make this functionality a reality by coding it yourself. As stated above, it is not so complicated to place a custom layout as a first or last item of RecyclerView. Besides providing a custom layout for those elements, you just have to include the header (or footer) element to the dataset and notify the Adapter. It’s a shame that such a common use case has to be coded in every single project.
Be careful when accessing the UI from a background thread
This is not a characteristic that is exclusive to RecyclerView, but I think it is important to mention it because this is a very common mistake.
In Android you can not access the UI from a background thread. This may be a problem when trying to update the adapter from a callback (for example: trying to notify the adapter of changes in the dataset after fetching data from the Internet) .
If you find yourself getting the following exception:
java.lang.IllegalStateException: Cannot call this method while RecyclerView is computing a layout or scrolling
This probably occurs because you are calling notifyItemInserted(position);, notifyItemChanged(position), or notifyItemRemoved(position); from a background thread (or from a callback, which runs on a background thread).
To solve this, use a handler:
android.os.Handler mHandler = getActivity().getWindow().getDecorView().getHandler();
mHandler.post(new Runnable() {
        public void run(){
                //change adapter contents
                mRecyclerViewAdapter.notifyItemInserted(position);
        }
});
